[{"title":"【公告】本站内容勘误 & Bug 反馈区 & 更新日志","url":"/2022/07/27/notice/","content":"<p>感谢读者访问本站。</p>\r\n<p>因为作者有时候脑抽或者其他原因，本站不可避免出现一些疏漏。如果你读书时遇到了一些困惑，也有可能是本站确实写错了。</p>\r\n<p>或者，如果你发现了本站的 Bug，也欢迎在本文下方的评论区中提出。</p>\r\n<p><del>（有没有感觉第二段特别熟悉，没错这是我从你谷的《深入浅出程序设计竞赛》的勘误区里复制过来的）</del></p>\r\n<h3 id=\"更新日志\">更新日志</h3>\r\n<ul>\r\n<li><p>2022/07/16: 搬运 OI-Wiki 到博客</p></li>\r\n<li><p>2022/07/27: 将所有图片迁移至 CSDN 或 SM.MS\r\n图床上，理论上不会再崩了<del>（要是这俩没了那我也没办法了）</del></p></li>\r\n</ul>\r\n"},{"title":"【题解】巨大 01 背包问题","url":"/2022/07/21/solution-huge_knapsack/","content":"<p>题目描述与 01 背包一模一样。不一样的地方在数据范围：</p>\r\n<blockquote>\r\n<p><span class=\"math inline\">\\(n(物品数量)\\leq 100, W(重量约束)\\leq10^9,\r\nw[i](第 i 件物品重量)\\leq 10^9, v[i](第 i 件物品价值)\\leq\r\n1000\\)</span></p>\r\n</blockquote>\r\n<p>发现：约束条件的数据范围非常大，所以无法使用常规的 01\r\n背包模板解决，会造成\r\nMLE。考虑这个问题的时候，可以从数据范围中获得提示。虽然约束条件的数据范围大，但是物品数量非常少。所以，可以考虑将目标与约束互换，即：</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th></th>\r\n<th>目标</th>\r\n<th>约束</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>传统 01 背包</td>\r\n<td>最大化总价值</td>\r\n<td>总重量 <span class=\"math inline\">\\(\\leq W\\)</span></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>巨大 01 背包</td>\r\n<td>最小化总重量</td>\r\n<td>总价值 <span class=\"math inline\">\\(\\geq V\\)</span></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>经过这样的转化后，能够想到两种定义状态的方法。</p>\r\n<ul>\r\n<li><code>f[i][j]</code> 表示只考虑前 <span\r\nclass=\"math inline\">\\(i\\)</span> 件物品能装下至少价值为 <span\r\nclass=\"math inline\">\\(p\\)</span> 的包最小载重是多少；</li>\r\n<li><code>f[i][j]</code> 表示只考虑前 <span\r\nclass=\"math inline\">\\(i\\)</span> 件物品能装下恰好价值为 <span\r\nclass=\"math inline\">\\(p\\)</span> 的包最小载重是多少。</li>\r\n</ul>\r\n<p>下面对这两种 DP 分别讨论。</p>\r\n<h4 id=\"解法-a\">解法 A</h4>\r\n<p>两种情况： <span class=\"math display\">\\[\r\n\\begin{cases}\r\n    f[i][j]=min(f[i-1][p],w[i]), v[i]&gt;p(单个物品就能完成) \\\\\r\n    f[i][j]=min(f[i-1][p], f[i-1][j-v[i]]+w[i]), else\r\n\\end{cases}\r\n\\]</span> 故代码为：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> LL;</span><br><span class=\"line\"><span class=\"type\">const</span> LL N = <span class=\"number\">109</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> LL MV = <span class=\"number\">1e5</span> + <span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> LL INF = <span class=\"number\">0x3F3F3F3F3F3F3F3F</span>;</span><br><span class=\"line\">LL n, W, V, w[N], v[N], f[N][MV];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;n, &amp;W);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (LL i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, w + i, v + i);</span><br><span class=\"line\">\tV = n * <span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (LL i = <span class=\"number\">1</span>; i &lt;= V; i++) f[<span class=\"number\">0</span>][i] = INF;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (LL i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (LL j = <span class=\"number\">0</span>; j &lt;= V; j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v[i] &gt; j) f[i][j] = std::<span class=\"built_in\">min</span>(f[i<span class=\"number\">-1</span>][j], w[i]);</span><br><span class=\"line\">    \t\t<span class=\"keyword\">else</span> f[i][j] = std::<span class=\"built_in\">min</span>(f[i<span class=\"number\">-1</span>][j], f[i<span class=\"number\">-1</span>][j-v[i]] + w[i]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = V; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f[n][i] &lt;= W) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, p);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"解法-b\">解法 B</h4>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> LL;</span><br><span class=\"line\"><span class=\"type\">const</span> LL N = <span class=\"number\">109</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> LL MV = <span class=\"number\">1e5</span> + <span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> LL INF = <span class=\"number\">0x3F3F3F3F3F3F3F3F</span>;</span><br><span class=\"line\">LL n, W, V, w[N], v[N], f[N][MV];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, &amp;n, &amp;W);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (LL i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld%lld&quot;</span>, w + i, v + i);</span><br><span class=\"line\">\tV = n * <span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (LL i = <span class=\"number\">1</span>; i &lt;= V; i++) f[<span class=\"number\">0</span>][i] = INF;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (LL i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (LL j = <span class=\"number\">0</span>; j &lt;= V; j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v[i] &gt; j) f[i][j] = f[i<span class=\"number\">-1</span>][j];</span><br><span class=\"line\">    \t\t<span class=\"keyword\">else</span> f[i][j] = std::<span class=\"built_in\">min</span>(f[i<span class=\"number\">-1</span>][j], f[i<span class=\"number\">-1</span>][j-v[i]] + w[i]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (LL i = V; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f[n][i] &lt;= W) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, i);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","categories":["题解"],"tags":["C++","动态规划","背包DP"]},{"title":"【专题】环形染色问题","url":"/2022/07/19/topic-math_ring_dyeing/","content":"<p><strong>本文转载自 <a href=\"https://zhuanlan.zhihu.com/p/507310484\">知乎</a></strong>，本文在原文的基础上做出了如下改进：</p>\n<ul>\n<li>重绘了所有插图，设计更加清新、间接、明了；</li>\n<li>将知乎所有公式图片换成 $\\LaTeX$。</li>\n</ul>\n<hr>\n<p>如图所示，一个圆环被分成 $m(m\\geq2)$ 块，用 $n(n\\geq2)$ 种不同颜色给每一块染色，要求相邻两块的颜色不相同。此类问题称之为环形染色问题。</p>\n<p><img src=\"https://s2.loli.net/2022/07/27/2aKgqkeuyVUQfF9.png\" alt=\"\"></p>\n<p>环形染色问题可以分为两种，一类是圆环中心区域要染色，一类是圆环中心区域不染色。因为中心区域染色问题在给中心涂色之后，剩余部分即为中心区域不染色的问题，所以本文重点讲解中心区域不染色问题。</p>\n<p>本文先针对 $m=4$、$m=5$ 以分类与分步的做法解决，而后给出此类问题的通解。</p>\n<h3 id=\"中心区域不染色\"><a href=\"#中心区域不染色\" class=\"headerlink\" title=\"中心区域不染色\"></a>中心区域不染色</h3><p><strong>$m=4, n=4$ 的情况</strong></p>\n<p>如图，环形区域被分成 $4$ 块，用 $4$ 种不同的颜色给这 $4$ 块区域染色，要求相邻区域颜色不同。</p>\n<p><img src=\"https://s2.loli.net/2022/07/27/5UeAbSRVoIFZ8zK.png\" alt=\"\"></p>\n<p>解：</p>\n<p>我们先给四块区域标注为 $A, B, C, D$。先给 $A$ 染色，则有 $4$ 种颜色，而后 $B$ 有三种，$C$ 也是有三种，但是 $D$ 则需要分类来讨论。因为 $D$ 与 $A, C$ 都相邻，且 $A,C$ 都已经涂好颜色，则 $A,C$ 若同色，则 $D$ 有三种颜色可选，$A,C$ 不同色，则 $D$ 只有两种颜色可以选择，如下图所示：</p>\n<p><img src=\"https://s2.loli.net/2022/07/27/ksDpK52GSEUfgry.png\" alt=\"\"></p>\n<p>则共有 $4\\times 3\\times (1\\times 3+2\\times 2)=84$ 种染色方式。</p>\n<p><strong>$m=5, n=4$ 的情况</strong></p>\n<p>如图，环形区域被分成 $5$ 块，用 $4$ 种不同的颜色给这 $5$ 块区域染色，要求相邻区域颜色不同。</p>\n<p><img src=\"https://s2.loli.net/2022/07/27/vRtPzrEfoi2WyC7.png\" alt=\"\"></p>\n<p>解：</p>\n<p>同上，给五块区域标注为 $A, B, C, D, E$。依旧是按顺序给 $5$ 块区域染色。则在考虑 $A, D$ 同色问题时，需考虑到 $A, C$ 是否同色。若 $A, C$ 同色，则 $A,D$ 必定不同色。只有 $A,C$ 不同色，才有可能出现 $A,D$ 同色。</p>\n<p>因此有以下分类：</p>\n<ol>\n<li>$A, C$ 同色：则 $A,D$ 必定不同色，则五块区域一次有 $4,3,1,3,2$ 种选法，共有 $4\\times 3\\times 1\\times 3\\times 2 = 72$ 种染色方式；</li>\n<li>$A,C$ 不同色：<ol>\n<li>$A,D$ 同色：则五块区域依次有 $4, 3, 2, 1, 3$ 种选法，共有 $4\\times 3\\times 1\\times 3\\times 2 = 72$ 种染色方式；</li>\n<li>$A,D$ 异色：则五块区域依次有 $4, 3, 2, 2, 2$ 种选法，共有 $4\\times 3\\times 2\\times 2\\times 2 = 96$ 种染色方式；</li>\n</ol>\n</li>\n</ol>\n<p>共计有 $72+72+96=240$ 种染色方式。</p>\n<p><strong>任意 $m\\geq 2,n\\geq 2$ 的情况</strong></p>\n<p>记当有 $m$ 块区域时，染色方法有 $a_m$ 种；则当 $m$ 取 $1,2,3,\\dots$ 时，分别有 $a_1,a_2,a_3,\\dots$ 种染色方式。</p>\n<p><img src=\"https://s2.loli.net/2022/07/27/2aKgqkeuyVUQfF9.png\" alt=\"\"></p>\n<p>首先考虑直线型染色：如下图所示，有 $m$ 块区域，$n$ 种颜色，要求相邻区域不同色。</p>\n<p><img src=\"https://s2.loli.net/2022/07/27/38p1LMxH5j9dVkB.png\" alt=\"\"></p>\n<p>则除了第一块有 $n$ 种涂法，其余各块都是 $n-1$ 种。则共有 $n(n-1)^{m-1}$ 种染色方式。</p>\n<p>现在把直线型的两端对接，拼成一个环形。</p>\n<p>当两端颜色相同时，首尾对接则会出现有两块相邻区域颜色相同。其余相邻区域颜色则均不同。此时若把相邻颜色相同的区域合并为一个区域，则此时的环形有 $m-1$ 块区域，任意相邻区域颜色均不相同，对应 $a_{m-1}$ 种染色方式。</p>\n<p>当两端颜色不同时，首尾对接，则任意相邻区域颜色均不相同，此时的环形有 $m$ 块区域，对应 $a_m$ 种染色方式。</p>\n<p>因此有 $a_m+a_{m-1}=n(n-1)^{m-1}$</p>\n<p>对其稍作变形，有：<br>$$<br>\\begin{aligned}<br>a_m+a_{m-1} &amp;= (n-1)(n-1)^{m-1}+(n-1)^{m-1}\\<br>            &amp;= (n-1)^m+(n-1)^{m-1}\\<br>\\end{aligned}<br>$$<br>移向可得：<br>$$<br>a_m-(n-1)^m=-(a_{m-1}-(n-1)^{m-1})<br>$$<br>分类讨论如下：</p>\n<ol>\n<li><p>$a_m-(n-1)^m = 0$</p>\n<p>即 $a_m=(n-1)^m$，考虑 $a_2=n(n-1)$，与之矛盾，舍；</p>\n</li>\n<li><p>$a_m-(n-1)^m \\ne 0$</p>\n<p>令 $b_m=a_m-(n-1)^m$，则有 $\\frac{b_m}{b_{m-1}} = -1$，为等比数列</p>\n<p>则 $b_m=(-1)^{m-2}\\times b_2=(-1)^m\\times b_2$</p>\n<p>代入 $b_2=a_2-(n-1)^2=n(n-1)-(n-1)^2=n-1$</p>\n<p>有 $b_m=(-1)^m\\times b_2=(-1)^m\\times (n-1)$</p>\n<p>代入 $b_m=a_m-(n-1)^m$</p>\n<p>有 $a_m=(n-1)^m+(-1)^m\\times (n-1)$</p>\n</li>\n</ol>\n<p>验证一下：</p>\n<ol>\n<li>代入 $m=4, n=4$，有 $3^4+3=84$</li>\n<li>代入 $m=5, n=4$，有 $3^5-3=240$</li>\n</ol>\n<h3 id=\"中心区域染色\"><a href=\"#中心区域染色\" class=\"headerlink\" title=\"中心区域染色\"></a>中心区域染色</h3><p>圆环有 $m$ 块区域，再加上中心区域共有 $m+1$ 块区域，有 $n+1$ 种颜色</p>\n<p>由于中心区域与外环所有区域均相邻，则先涂中心区域，有 $n+1$ 种涂色方法；</p>\n<p>此时余下 $m$ 块区域与 $n$ 种颜色，即为中心不染色时 $m$ 块区域和 $n$ 种颜色的环形染色问题，代入上述公式，共有 $a_m=(n-1)^m+(-1)^m\\times(n-1)$ 种染色方法。</p>\n<p>合计共有 $(n+1)\\times a_m=(n+1)\\times [(n-1)^m+(-1)^m\\times(n-1)]$ 种染色方法。</p>\n","categories":["专题"],"tags":["数学"]},{"title":"【专题】那些被忽略的细节","url":"/2022/07/13/topic-basicalg/","content":"<h3 id=\"关于浮点数\"><a href=\"#关于浮点数\" class=\"headerlink\" title=\"关于浮点数\"></a>关于浮点数</h3><p>请先阅读下面的程序，并猜测输出：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">double</span> eps = <span class=\"number\">1e-6</span>;</span><br><span class=\"line\"><span class=\"type\">double</span> x = <span class=\"number\">5.2</span>, y = <span class=\"number\">5.1</span> + <span class=\"number\">0.1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, x == y);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, x &lt; y);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, x &gt; y);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%e\\n&quot;</span>, x - y); <span class=\"comment\">// %e 是科学计数法的意思</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, <span class=\"built_in\">fabs</span>(x-y) &lt; eps);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, x &gt; y + eps);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大多数同学预测的输出应该是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">0</span><br><span class=\"line\">0</span><br><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<p>然而，正确的输出应该是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">8.88178e-16</span><br><span class=\"line\">1</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<p>是不是令你大吃一惊呢？让我来解释一下这个现象的原因。说到底，就是一个精度问题。</p>\n<p>系统中的数据都是以二进制形式存储的。</p>\n<p>例如：$114514 = 2^{1}+2^{4}+2^{6}+2^{8}+2^{9}+2^{10}+2^{11}+2^{12}+2^{13}+2^{15}+2^{16}$</p>\n<p>在存储小数的时候，可能会遇到精度不够的问题。这就导致了在存储时与原数会有一点点的差距。差距一般在 $0.000001$ 左右。所以，当我们想要判断两个浮点数是否相等时，只需判断两数之差是否小于 $0.000001$ 即可。如果小于，则判断两个浮点数相等（如前面的程序的第 $10$ 行所示）。</p>\n<p>同理，我们可以推出 $&gt;\\ &lt;\\ \\leq\\ \\geq$ 的判断式（$eps=10^{-6}$）：</p>\n<table>\n<thead>\n<tr>\n<th>判断内容</th>\n<th>具体写法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>判断浮点数 <code>==</code></td>\n<td><code>fabs(x-y) &lt; eps</code></td>\n</tr>\n<tr>\n<td>判断浮点数 <code>&gt;</code></td>\n<td><code>x &gt; y + eps</code></td>\n</tr>\n<tr>\n<td>判断浮点数 <code>&lt;</code></td>\n<td><code>x &lt; y - eps</code></td>\n</tr>\n<tr>\n<td>判断浮点数 <code>&gt;=</code></td>\n<td><code>x &gt; y - eps</code></td>\n</tr>\n<tr>\n<td>判断浮点数 <code>&lt;=</code></td>\n<td><code>x &lt; y + eps</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"关于输出\"><a href=\"#关于输出\" class=\"headerlink\" title=\"关于输出\"></a>关于输出</h3><p>输出，那各位可再熟悉不过了。可别小看了输出，其中依然有坑。</p>\n<p>常见的输出函数有四种：<code>cout</code>、<code>printf</code>、<code>puts</code>、<code>putchar</code>。关于它们的用法，请出门左转到 CSDN。</p>\n<p>我们还是先来看一段程序。这段程序从是我的 <a href=\"https://willhou936.github.io/2022/06/26/fun-homo/\">这篇博客</a> 中摘录的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">32</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n, a[N];</span><br><span class=\"line\"><span class=\"type\">bool</span> isFirst = <span class=\"literal\">true</span>;</span><br><span class=\"line\">string s[N] = &#123;<span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;11/(45-1)*4&quot;</span>, <span class=\"string\">&quot;-11+4-5+14&quot;</span>, <span class=\"string\">&quot;-11-4+5+14&quot;</span>, <span class=\"string\">&quot;11-4+5/1-4&quot;</span>, <span class=\"string\">&quot;11-4-5+14&quot;</span>, <span class=\"string\">&quot;1*1+45-14&quot;</span>, <span class=\"string\">&quot;11*4+5*1*4&quot;</span>, <span class=\"string\">&quot;1+1+(4+5)*14&quot;</span>, <span class=\"string\">&quot;(114-51)*4+(-11-4+5+14)&quot;</span>, <span class=\"string\">&quot;1+1-4+514&quot;</span>, <span class=\"string\">&quot;1*(1+4)*51*4+(-11-4+5+14)&quot;</span>, <span class=\"string\">&quot;-11+4*514+(11*-4+51-4)&quot;</span>, <span class=\"string\">&quot;(1+1)*451*4+(11*(45-1)+4)&quot;</span>, <span class=\"string\">&quot;114*5*14+((1+1)*4+51*4)&quot;</span>, <span class=\"string\">&quot;1145*14+((11-4)*51-4+(11/(45-1)*4))&quot;</span>, <span class=\"string\">&quot;114*51*4+((1+1)*4514+(11*45-14+(11*-4+51-4)))&quot;</span>, <span class=\"string\">&quot;114*514+(11*45*14+(-11/4+51/4))&quot;</span>, <span class=\"string\">&quot;114514+(1145*14+(1*14+514))&quot;</span>, <span class=\"string\">&quot;114514*(-11+4-5+14)+(114*51*4+((1+1)*4514+(11+4*51*4+(11-4*5+14))))&quot;</span>, <span class=\"string\">&quot;114514*(-11-4+5+14)+(114*514+(1+14*514+((1+145)*-(1-4)+(11/(45-1)*4))))&quot;</span>, <span class=\"string\">&quot;114514*(11-4+5+1-4)+(1145*14+((11+451)*4+(-1-1+4+5*14)))&quot;</span>, <span class=\"string\">&quot;114514*(1+1+4*5*1-4)+(114*51*4+(11451+4+(1145+14+(1*-1+45-14))))&quot;</span>, <span class=\"string\">&quot;114514*(11+4*5+1+4)+(114*514+(11451+4+(114*-5*(1-4)+(-11+45+1+4))))&quot;</span>, <span class=\"string\">&quot;114514*(1*14*5-1+4)+(114*51*4+(114*51+4+(-11+4+5+14)))&quot;</span>, <span class=\"string\">&quot;114514*(11+45*-(1-4))+(11*4514+(114*5*14+(1+14+514+(11-4+5+1-4))))&quot;</span>, <span class=\"string\">&quot;114514*(11+4*5*14+(-11+4-5+14))+(114*(5-1)*4+(1-14+5+14))&quot;</span>, <span class=\"string\">&quot;114514*(114*5+14+(-11+4-5+14))+((1+1)*451*4+(11+45/1-4))&quot;</span>, <span class=\"string\">&quot;114514*(1145+14+(1*14-5/1+4))+(1+14*514+(114-5+14))&quot;</span>, <span class=\"string\">&quot;114514*(114*5*1*4+(11*4+5*1*4))+(1+14514+(-1-14*(5-14)))&quot;</span>, <span class=\"string\">&quot;114514*((1145+1)*4+(114-5-1-4))+(114*51*4+(114*51+4+(11*4*5-14)))&quot;</span>, <span class=\"string\">&quot;114514*((1+1)*4514+(11*(45-14)+(11-4+5-1-4)))+(11*4514+(114*5*14+(-(1-14)*5*14+(11-4-5+14))))&quot;</span>&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isFirst) &#123;</span><br><span class=\"line\">        isFirst = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s[x][<span class=\"number\">0</span>] != <span class=\"string\">&#x27;-&#x27;</span>) cout &lt;&lt; <span class=\"string\">&#x27;+&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; s[x];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">BinarySplit</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">30</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((<span class=\"number\">1</span>&lt;&lt;i) &amp; x)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(i+<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>); cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">BinarySplit</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是正解程序。但是，一开始，我的 <code>print</code> 函数是这样写的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isFirst) &#123;</span><br><span class=\"line\">        isFirst = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s[x][<span class=\"number\">0</span>] != <span class=\"string\">&#x27;-&#x27;</span>) <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;+&#x27;</span>); <span class=\"comment\">// 区别在这</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; s[x];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>乍一看，似乎没有什么区别。但当我随便输入一个数（例如 $114514$）时，输出是这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">++++++++114*514+(11*45*14+(-11/4+51/4))114*51*4+((1+1)*4514+(11*45-14+(11*-4+51-4)))114*5*14+((1+1)*4+51*4)(1+1)*451*4+(11*(45-1)+4)-11+4*514+(11*-4+51-4)1*(1+4)*51*4+(-11-4+5+14)1+1-4+514(114-51)*4+(-11-4+5+14)11*4+5*1*411-4-5+14-11+4-5+14</span><br></pre></td></tr></table></figure>\n\n<p>我调了半天，也不知道哪里出了问题，索性把 <code>putchar</code> 改成了 <code>cout</code>。结果发现，问题竟然解决了！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">114*514+(11*45*14+(-11/4+51/4))+114*51*4+((1+1)*4514+(11*45-14+(11*-4+51-4)))+114*5*14+((1+1)*4+51*4)+(1+1)*451*4+(11*(45-1)+4)-11+4*514+(11*-4+51-4)+1*(1+4)*51*4+(-11-4+5+14)+1+1-4+514+(114-51)*4+(-11-4+5+14)+11*4+5*1*4+11-4-5+14-11+4-5+14</span><br></pre></td></tr></table></figure>\n\n<p>当时我就懵了。怎么会这样呢？这个问题我到现在也没搞懂。如果有大神知道原因，请不吝指教，谢谢！</p>\n<p>总之，这个例子说明了：千万不要把各种输出混用。<code>C</code> 风格就全程 <code>C</code> 风格，<code>C++</code> 就全程 <code>C++</code>。</p>\n","categories":["专题"],"tags":["C++","算法基础"]},{"title":"【题解】P1553 数字反转（升级版）","url":"/2022/07/08/solution-number_reverse/","content":"<p>原题链接：<a\r\nhref=\"https://www.luogu.com.cn/problem/P1553\">点我跳转</a></p>\r\n<p>此题思维难度不大，考察选手对于细节的把控。</p>\r\n<p>本题分为四种情况：</p>\r\n<ul>\r\n<li><p>整数</p></li>\r\n<li><p>浮点数</p></li>\r\n<li><p>分数</p></li>\r\n<li><p>百分数</p></li>\r\n</ul>\r\n<p>看似情况很多，实则需要做的操作是一样的。都是 <strong>反转 + 去掉前导0\r\n+ 可能的要去掉中间的0 + 可能的要去掉后缀0</strong></p>\r\n<h4 id=\"反转\">反转</h4>\r\n<p>使用双指针，交换 <code>s[i]</code> 与 <code>s[j]</code>\r\n的值即可。其中，<span class=\"math inline\">\\(1\\leq i&lt; j\\leq\r\nN\\)</span>。</p>\r\n<h4 id=\"去掉前导-0\">去掉前导 0</h4>\r\n<p>换种思路，去掉前导 <span class=\"math inline\">\\(0\\)</span>\r\n也可以从第一个不为 <span class=\"math inline\">\\(0\\)</span>\r\n的地方开始输出。</p>\r\n<h4 id=\"去掉中间的-0\">去掉中间的 0</h4>\r\n<p>这里使用一种暴力的方法，就是把中间的 0\r\n换成空格，最后不输出空格即可。</p>\r\n<h4 id=\"去掉后缀-0\">去掉后缀 0</h4>\r\n<p>从后向前遍历，找到第一个不为零的地址，把它的下一个值标记为结束符。</p>\r\n<hr />\r\n<p>这样，就大致梳理好了思路，即可快乐地写代码了。</p>\r\n<p><del>写完题解才发现这种方法挺麻烦的。</del></p>\r\n<p><del>不要问我为什么不用 <code>string</code>，写 <code>char</code>\r\n数组写习惯了。</del></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">109</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> st;</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"type\">char</span> &amp;a, <span class=\"type\">char</span> &amp;b)</span> </span>&#123; <span class=\"type\">char</span> t = a; a = b; b = t; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"type\">char</span> *s, <span class=\"type\">int</span> st, <span class=\"type\">int</span> ed)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i = st, j = ed;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(s[i], s[j]);</span><br><span class=\"line\">\t\ti++, j--;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 反转</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find_st</span><span class=\"params\">(<span class=\"type\">char</span> *s, <span class=\"type\">int</span> st, <span class=\"type\">int</span> ed)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = st; i &lt;= ed; i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s[i] != <span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">erase_ed</span><span class=\"params\">(<span class=\"type\">char</span> *s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i = <span class=\"built_in\">strlen</span>(s) - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (s[i--] == <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">\ts[i+<span class=\"number\">2</span>] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">erase_md</span><span class=\"params\">(<span class=\"type\">char</span> *s, <span class=\"type\">int</span> st)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i = st;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (s[i] == <span class=\"string\">&#x27;0&#x27;</span>) s[i++] = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, s);</span><br><span class=\"line\">\t<span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">strchr</span>(s, <span class=\"string\">&#x27;%&#x27;</span>) - s &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">reverse</span>(s, <span class=\"number\">0</span>, len<span class=\"number\">-2</span>);</span><br><span class=\"line\">\t\tst = <span class=\"built_in\">find_st</span>(s, <span class=\"number\">0</span>, len<span class=\"number\">-2</span>);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">strchr</span>(s, <span class=\"string\">&#x27;.&#x27;</span>) - s &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> add = <span class=\"built_in\">strchr</span>(s, <span class=\"string\">&#x27;.&#x27;</span>) - s;</span><br><span class=\"line\">\t\t<span class=\"built_in\">reverse</span>(s, <span class=\"number\">0</span>, add<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\tst = <span class=\"built_in\">find_st</span>(s, <span class=\"number\">0</span>, add<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">reverse</span>(s, add+<span class=\"number\">1</span>, len<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">erase_ed</span>(s);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s[<span class=\"built_in\">strlen</span>(s)<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;.&#x27;</span>)</span><br><span class=\"line\">\t\t\ts[<span class=\"built_in\">strlen</span>(s)] = <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">strchr</span>(s, <span class=\"string\">&#x27;/&#x27;</span>) - s &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> add = <span class=\"built_in\">strchr</span>(s, <span class=\"string\">&#x27;/&#x27;</span>) - s;</span><br><span class=\"line\">\t\t<span class=\"built_in\">reverse</span>(s, <span class=\"number\">0</span>, add<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\tst = <span class=\"built_in\">find_st</span>(s, <span class=\"number\">0</span>, add<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">reverse</span>(s, add+<span class=\"number\">1</span>, len<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">erase_md</span>(s, add+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = st; s[i]; i++)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (s[i] != <span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">putchar</span>(s[i]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">reverse</span>(s, <span class=\"number\">0</span>, len<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\tst = <span class=\"built_in\">find_st</span>(s, <span class=\"number\">0</span>, len<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s&quot;</span>, s + st);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>其实用 <code>string</code> 应该会更简单亿点，直接\r\n<code>stringstream</code>。<del>但些都写完了就懒得再写其他方法了。</del></p>\r\n","categories":["题解"],"tags":["C++","算法基础","字符串"]},{"title":"【题解】CSP 模拟赛第一场题解","url":"/2022/07/04/solution-csp_test_1/","content":"<h3 id=\"t1.-不重最长子串\">T1. 不重最长子串</h3>\r\n<p>Link：<a href=\"https://www.mfstem.org/p/1340\">点我跳转</a></p>\r\n<p>题目概括：给定一个字符串 <span\r\nclass=\"math inline\">\\(s\\)</span>，找出其中不含有重复字符的<strong>最长子串</strong>的长度。字符串由英文字母、数字和空格组成。长度在\r\n<span class=\"math inline\">\\(0\\sim 50000\\)</span> 之间</p>\r\n<p>关于子串的定义，请出门右转到<a\r\nhref=\"https://baike.baidu.com/item/%E5%AD%90%E4%B8%B2/11047664\">百度百科</a></p>\r\n<p>一道水题，但还是有亿些技巧。</p>\r\n<p>技巧：<code>loc[i]</code> 标记 <span class=\"math inline\">\\(i\\)</span>\r\n出现的位置，求最长 /\r\n不重复问题时会使用到。具体到这一题，<code>loc[i]</code> 表示第 <span\r\nclass=\"math inline\">\\(i\\)</span> 个字符上一次出现的位置。</p>\r\n<p>记录每一个字符之前相同字符出现的位置，否则初始位置全部为 <span\r\nclass=\"math inline\">\\(-1\\)</span>，也可以直接计算，每一次计算可以形成最长的序列长度然后更新。</p>\r\n<p>核心思想：先定后配。即枚举一个端点，匹配另一个端点。具体到这一题，是枚举右端点，匹配左端点。</p>\r\n<p>需要注意的是这个大坑：字符串也可以由<strong>空格</strong>组成。所以一定要用\r\n<code>getline</code>。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">5e4</span> + <span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> ans, pos[N], loc[<span class=\"number\">130</span>];</span><br><span class=\"line\">string s;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">getline</span>(cin, s);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(loc, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> loc);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">        pos[i] = loc[s[i]], loc[s[i]] = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; j &lt; s.<span class=\"built_in\">size</span>(); j++) &#123; <span class=\"comment\">// i-left, j-right</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pos[j] &gt;= i) i = pos[j] + <span class=\"number\">1</span>;</span><br><span class=\"line\">        ans = j-i+<span class=\"number\">1</span> &gt; ans ? j-i+<span class=\"number\">1</span> : ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, ans);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>还有这种写法，是比较好想到的，就不做过多的解释，看注释即可。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">130</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> loc[N], l, mx; <span class=\"comment\">// l-左端点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    <span class=\"built_in\">getline</span>(cin, s);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(loc, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> loc);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loc[s[i]] &gt;= l) &#123; <span class=\"comment\">// 出现了两次</span></span><br><span class=\"line\">            l = loc[s[i]] + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mx = <span class=\"built_in\">max</span>(mx, i-l+<span class=\"number\">1</span>); <span class=\"comment\">// 更新最大值</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        loc[s[i]] = i; <span class=\"comment\">// 更新上一次出现的位置</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; mx;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"t2.-小j的加密算法\">T2. 小J的加密算法</h3>\r\n<p>Link：<a href=\"https://www.mfstem.org/p/1341\">点我跳转</a></p>\r\n<p>题目概括：输入一个字符串，将其按照 <code>Z</code>\r\n字形重新排列，输出排列后的样子。例如：有字符串\r\n<code>LSRDCYJDL</code>，<code>Z</code> 字形的行数为 <span\r\nclass=\"math inline\">\\(3\\)</span>，该字符串应该长这样：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">L   C   L</span><br><span class=\"line\">S D Y D</span><br><span class=\"line\">R   J</span><br></pre></td></tr></table></figure>\r\n<p>输出应该长这样（按行输出）：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">LCLSDYDRJ</span><br></pre></td></tr></table></figure>\r\n<p><del>（关于这个字符串的意思，我不敢多说，有知道的评论区见）</del></p>\r\n<p>水题，找规律即可。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1009</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> col, c;</span><br><span class=\"line\"><span class=\"type\">char</span> m[N][N];</span><br><span class=\"line\">string s;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin &gt;&gt; s &gt;&gt; c;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        cout &lt;&lt; s;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>, r = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (col%(c<span class=\"number\">-1</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            m[r++][col] = s[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r == c)</span><br><span class=\"line\">                r = c - <span class=\"number\">2</span>, col++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            m[r--][col++] = s[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; c; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt;= col; j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m[i][j])</span><br><span class=\"line\">                <span class=\"built_in\">putchar</span>(m[i][j]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"t3.-数列的个数\">T3. 数列的个数</h3>\r\n<p>Link：<a href=\"https://www.mfstem.org/p/1342\">点我跳转</a></p>\r\n<p>题目概括：给出两个整数 <span class=\"math inline\">\\(n,\r\nm\\)</span>。问有多少个长度为 <span class=\"math inline\">\\(n\\)</span>\r\n的序列 <span class=\"math inline\">\\(A\\)</span>，满足以下条件：</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(1 ≤ A_i ≤ m(i = 1, 2,\\dots,\r\nn)\\)</span></li>\r\n<li><span class=\"math inline\">\\(\\forall i\\in [1, n-1]\\)</span>，<span\r\nclass=\"math inline\">\\(A_{i+1}\\)</span> 是 <span\r\nclass=\"math inline\">\\(A_i\\)</span> 的倍数。</li>\r\n</ul>\r\n<p>由于答案可能很大，所以你只需要输出答案对 <span\r\nclass=\"math inline\">\\(998244353\\)</span> 取模的结果。</p>\r\n<p>比较难，放洛谷应该是绿题的水平。</p>\r\n<p>本题的核心思想仍然是“先定后配”。</p>\r\n<p>分析过程如下：</p>\r\n<p><strong>关键词：倍数</strong></p>\r\n<p>因为 <span class=\"math inline\">\\(A_{i+1}\\)</span> 是 <span\r\nclass=\"math inline\">\\(A_i\\)</span> 的倍数，所以 <span\r\nclass=\"math inline\">\\(A_i\\)</span> 一定是 <span\r\nclass=\"math inline\">\\(A_{i+1}\\)</span>\r\n的约数。故这题会用到约数分解。</p>\r\n<p><strong>找规律</strong> <span class=\"math inline\">\\(n=3,\r\nm=4:\\)</span></p>\r\n<p>枚举所有情况：</p>\r\n<p><img\r\nsrc=\"https://img-blog.csdnimg.cn/img_convert/219745618ccb15d7b9abcdd2351044a1.png\" /></p>\r\n<p>如果从第一个数开始向后推，并不方便发现规律。不妨先定下最后一个数，往前推前面的数。该思想称为：正难则反。</p>\r\n<p>例如，以 <span class=\"math inline\">\\(4\\)</span> 为结尾的数列： <img\r\nsrc=\"https://img-blog.csdnimg.cn/img_convert/053140d295aea3fd2fe0ca0de02874e1.png\" />\r\n归结起来，就是： <span class=\"math display\">\\[\r\n\\begin{cases}\r\n    x\\stackrel{\\times 2^{a}}{\\longrightarrow}y\\stackrel{\\times\r\n2^{b}}{\\longrightarrow}4\\\\\r\n    a + b \\leq 2\r\n\\end{cases}\r\n\\]</span> 所以，欲求以 <span class=\"math inline\">\\(4\\)</span>\r\n结尾的数列的方案数，即是求 <span class=\"math inline\">\\(a+b\\leq2\\)</span>\r\n有多少种可能。</p>\r\n<p>方便起见，把 <span class=\"math inline\">\\(\\leq\\)</span> 换成 <span\r\nclass=\"math inline\">\\(=\\)</span>，我们再设一个未知数 <span\r\nclass=\"math inline\">\\(c\\)</span> <span class=\"math display\">\\[\r\na+b+c=2\r\n\\]</span> 这样，我们就把这个问题转换为：有 <span\r\nclass=\"math inline\">\\(n\\)</span> 个自然数相加的和为 <span\r\nclass=\"math inline\">\\(k\\)</span>，解有多少种。</p>\r\n<p>分析这个问题，可以用“隔板法”。注意：此处的隔板法是<strong>允许将多个板子插在一个空中</strong>的。</p>\r\n<p><img\r\nsrc=\"https://img-blog.csdnimg.cn/img_convert/3de8602ec3c8120adb01f9d03bfcb84d.png\" /></p>\r\n<p>有 <span class=\"math inline\">\\(C^{k}_{n-1+k}\\)</span>\r\n种方法。但是这种方法时间复杂度巨大，所以需要借助背包求解。</p>\r\n<p>令 <code>f[i][j]</code> 表示前 <span class=\"math inline\">\\(i\\)</span>\r\n个数用掉 <span class=\"math inline\">\\(j\\)</span> 个因子后的情况数。</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">f[i][j] = f[i-1][j] + f[i-1][j-1] + f[i-1][j-2] + ... + f[i-1][0]</span><br><span class=\"line\">        = f[i-1][j] + f[i][j-1] // 完全背包</span><br></pre></td></tr></table></figure>\r\n<p>降维后：<code>f[j] = f[j] + f[j-1]</code> 即\r\n<code>f[j] += f[j-1]</code>。</p>\r\n<p>这样就将组合数预处理出来了。</p>\r\n<p><del>呼，终于到了上代码时间。码字码了几个小时了。</del></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> M = <span class=\"number\">998244353</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> f[<span class=\"number\">20</span>] = &#123;<span class=\"number\">1</span>&#125;, n, m;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i*i &lt;= k; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k % i) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k%i == <span class=\"number\">0</span>) k /= i, ++c;</span><br><span class=\"line\">        ans = ans * <span class=\"number\">1LL</span> * f[c] % M;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k &gt; <span class=\"number\">1</span>) ans = ans * <span class=\"number\">1LL</span> * f[<span class=\"number\">1</span>] % M; <span class=\"comment\">// 质数情况</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= <span class=\"number\">19</span>; ++j)</span><br><span class=\"line\">            (f[j] += f[j<span class=\"number\">-1</span>]) %= M;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; ++i)</span><br><span class=\"line\">        (ans += <span class=\"built_in\">solve</span>(i)) %= M;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, ans);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"t4.-匹配正则表达式\">T4. 匹配正则表达式</h3>\r\n<p>Link：<a href=\"https://www.mfstem.org/p/1343\">点我跳转</a></p>\r\n<p>先抖个机灵。C++ 头文件里内带正则表达式 <code>regex</code>\r\n库，所以只需要调用库函数 <code>regex_match</code> 即可。</p>\r\n<p>关于 <code>regex</code> 库的更多用法，请参考<a\r\nhref=\"https://blog.csdn.net/asialee_bird/article/details/103420321\">这篇博客</a></p>\r\n<p>AC 代码：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;regex&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">string s, p;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cin &gt;&gt; s &gt;&gt; p) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"built_in\">regex_match</span>(s, <span class=\"built_in\">regex</span>(p));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ans) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Yes&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;No&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>但这题显然不是考察我们的函数储备量，所以还要介绍下面这个方法。</p>\r\n<p>本题的思路与 <a\r\nhref=\"https://www.luogu.com.cn/problem/P1439\">最长公共子序列(LCS)</a>\r\n比较相似。<code>f[i][j]</code> 表示 <span\r\nclass=\"math inline\">\\(s\\)</span> 的前 <span\r\nclass=\"math inline\">\\(i\\)</span> 个字符与 <span\r\nclass=\"math inline\">\\(p\\)</span> 中的前 <span\r\nclass=\"math inline\">\\(j\\)</span>\r\n个字符是否能够匹配。在进行状态转移时，我们考虑 <span\r\nclass=\"math inline\">\\(p\\)</span> 的第 <span\r\nclass=\"math inline\">\\(j\\)</span> 个字符的匹配情况。</p>\r\n<p><code>p[j]</code> 是一个小写字母 <code>a-z</code>，则\r\n<code>s[i]</code> 必须也为同样的小写字母方能完成匹配。</p>\r\n<p>当 <code>p[j] = '.'</code> 时，<code>p[j]</code> 与 <code>s[i]</code>\r\n一定能匹配成功；</p>\r\n<p>当 <code>p[j] = '*'</code> 时，表示可对 <code>p[j]</code>\r\n的前一个字符 <code>p[j−1]</code> 匹配（或理解为复制）任意次（包括 <span\r\nclass=\"math inline\">\\(0\\)</span> 次）。 <span class=\"math display\">\\[\r\ndp[i][j] =\r\n\\begin{cases}\r\n\\ dp[i-1][j-1],\\ s[i]=p[j]\\\\\r\n\\ dp[i][j-2],\\ p[j]=&#39;*&#39;\\ \\&amp;\\ s[i]\\ne p[j-1]:\\\\\r\n\\ dp[i][j-2]\\ or\\ dp[i-1][j],\\ p[j]=&#39;*&#39;\\ \\&amp;\\ s[i]= p[j-1]:\r\n\\end{cases}\r\n\\]</span></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">string s, p;</span><br><span class=\"line\"><span class=\"type\">bool</span> dp[<span class=\"number\">50</span>][<span class=\"number\">50</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"type\">int</span> i, <span class=\"type\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p[j<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;.&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s[i<span class=\"number\">-1</span>] == p[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cin &gt;&gt; s &gt;&gt; p) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> n = p.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(dp, <span class=\"literal\">false</span>, <span class=\"keyword\">sizeof</span> dp);</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= m; i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p[j<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;*&#x27;</span>) &#123;</span><br><span class=\"line\">                    dp[i][j] |= dp[i][j<span class=\"number\">-2</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"built_in\">check</span>(i, j<span class=\"number\">-1</span>))</span><br><span class=\"line\">                        dp[i][j] |= dp[i<span class=\"number\">-1</span>][j];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">check</span>(i, j)) &#123;</span><br><span class=\"line\">                    dp[i][j] |= dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dp[m][n])</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;Yes&quot;</span> &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;No&quot;</span> &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","categories":["题解"],"tags":["C++","算法基础","字符串","动态规划"]},{"title":"【趣味】恶臭数字论证器","url":"/2022/06/26/fun-homo/","content":"<p>灵感来源：<a href=\"https://github.com/itorr/homo\">Github_homo</a></p>\n<p>刷 Github 看到的项目，很有意思，就想着自己写一个。</p>\n<p>众所周知，任意一个十进制数都可以拆分成若干个二进制数相加，所以只需要将所有的二的整数次幂用 114514 表示一遍，再将输入的数拆分成二进制数，最后输出即可。<del>此处应该上打表</del></p>\n<p>原理就是这样，下面上大家最喜欢的代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">32</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n, a[N];</span><br><span class=\"line\"><span class=\"type\">bool</span> isFirst = <span class=\"literal\">true</span>;</span><br><span class=\"line\">string s[N] = &#123;<span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;11/(45-1)*4&quot;</span>, <span class=\"string\">&quot;-11+4-5+14&quot;</span>, <span class=\"string\">&quot;-11-4+5+14&quot;</span>, <span class=\"string\">&quot;11-4+5/1-4&quot;</span>, <span class=\"string\">&quot;11-4-5+14&quot;</span>, <span class=\"string\">&quot;1*1+45-14&quot;</span>, <span class=\"string\">&quot;11*4+5*1*4&quot;</span>, <span class=\"string\">&quot;1+1+(4+5)*14&quot;</span>, <span class=\"string\">&quot;(114-51)*4+(-11-4+5+14)&quot;</span>, <span class=\"string\">&quot;1+1-4+514&quot;</span>, <span class=\"string\">&quot;1*(1+4)*51*4+(-11-4+5+14)&quot;</span>, <span class=\"string\">&quot;-11+4*514+(11*-4+51-4)&quot;</span>, <span class=\"string\">&quot;(1+1)*451*4+(11*(45-1)+4)&quot;</span>, <span class=\"string\">&quot;114*5*14+((1+1)*4+51*4)&quot;</span>, <span class=\"string\">&quot;1145*14+((11-4)*51-4+(11/(45-1)*4))&quot;</span>, <span class=\"string\">&quot;114*51*4+((1+1)*4514+(11*45-14+(11*-4+51-4)))&quot;</span>, <span class=\"string\">&quot;114*514+(11*45*14+(-11/4+51/4))&quot;</span>, <span class=\"string\">&quot;114514+(1145*14+(1*14+514))&quot;</span>, <span class=\"string\">&quot;114514*(-11+4-5+14)+(114*51*4+((1+1)*4514+(11+4*51*4+(11-4*5+14))))&quot;</span>, <span class=\"string\">&quot;114514*(-11-4+5+14)+(114*514+(1+14*514+((1+145)*-(1-4)+(11/(45-1)*4))))&quot;</span>, <span class=\"string\">&quot;114514*(11-4+5+1-4)+(1145*14+((11+451)*4+(-1-1+4+5*14)))&quot;</span>, <span class=\"string\">&quot;114514*(1+1+4*5*1-4)+(114*51*4+(11451+4+(1145+14+(1*-1+45-14))))&quot;</span>, <span class=\"string\">&quot;114514*(11+4*5+1+4)+(114*514+(11451+4+(114*-5*(1-4)+(-11+45+1+4))))&quot;</span>, <span class=\"string\">&quot;114514*(1*14*5-1+4)+(114*51*4+(114*51+4+(-11+4+5+14)))&quot;</span>, <span class=\"string\">&quot;114514*(11+45*-(1-4))+(11*4514+(114*5*14+(1+14+514+(11-4+5+1-4))))&quot;</span>, <span class=\"string\">&quot;114514*(11+4*5*14+(-11+4-5+14))+(114*(5-1)*4+(1-14+5+14))&quot;</span>, <span class=\"string\">&quot;114514*(114*5+14+(-11+4-5+14))+((1+1)*451*4+(11+45/1-4))&quot;</span>, <span class=\"string\">&quot;114514*(1145+14+(1*14-5/1+4))+(1+14*514+(114-5+14))&quot;</span>, <span class=\"string\">&quot;114514*(114*5*1*4+(11*4+5*1*4))+(1+14514+(-1-14*(5-14)))&quot;</span>, <span class=\"string\">&quot;114514*((1145+1)*4+(114-5-1-4))+(114*51*4+(114*51+4+(11*4*5-14)))&quot;</span>, <span class=\"string\">&quot;114514*((1+1)*4514+(11*(45-14)+(11-4+5-1-4)))+(11*4514+(114*5*14+(-(1-14)*5*14+(11-4-5+14))))&quot;</span>&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isFirst) &#123;</span><br><span class=\"line\">        isFirst = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s[x][<span class=\"number\">0</span>] != <span class=\"string\">&#x27;-&#x27;</span>) cout &lt;&lt; <span class=\"string\">&#x27;+&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; s[x];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">BinarySplit</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">30</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((<span class=\"number\">1</span>&lt;&lt;i) &amp; x)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(i+<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>); cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">BinarySplit</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该代码只支持拆分 $1\\le n\\le 2147483647$ 的数</p>\n<p>最后附上原项目链接：<a href=\"https://lab.magiconch.com/homo/\">恶臭数字论证器</a>，比我写的要强大很多<del>（谁叫人家是 js 呢）</del>。</p>\n","categories":["趣味"],"tags":["C++","算法基础"]},{"title":"【专题】栈","url":"/2022/06/14/topic-ds_stack/","content":"<h3 id=\"栈的定义\">栈的定义</h3>\r\n<p>栈是限制插入和删除操作只能在一个位置上进行的表。它是一种 ==LIFO(Last\r\nIn First Out)== 线性表。</p>\r\n<p>表的末端成为栈的<strong>顶(top)</strong></p>\r\n<p><img src=\"https://s2.loli.net/2022/05/15/vHj5GwAotcmnBWh.png\" alt=\"top\" style=\"zoom:50%;\" /></p>\r\n<h3 id=\"栈的操作与实现\">栈的操作与实现</h3>\r\n<h4 id=\"数组实现\">数组实现</h4>\r\n<p><strong>以下代码前提：</strong></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1009</span>; <span class=\"comment\">// 按需定</span></span><br><span class=\"line\"><span class=\"type\">int</span> stk[N], tp;</span><br></pre></td></tr></table></figure>\r\n<ol type=\"1\">\r\n<li><p><code>push</code> 操作(入栈)</p>\r\n<blockquote>\r\n<p>注意事项：入栈前务必要检查栈是否为满。</p>\r\n<p>不过，一般情况下，栈定义的大小总比题目中要求的大，所以可以不判断是否满。</p>\r\n</blockquote>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tp == N)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 以上代码可写可不写</span></span><br><span class=\"line\">   \tstk[++tp] = x;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n<li><p><code>pop</code> 操作(出栈)</p>\r\n<blockquote>\r\n<p>注意事项：出栈前务必要检查栈是否为空。</p>\r\n</blockquote>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tp == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">   \ttp--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n<li><p><code>isEmpty</code> 操作(判断栈是否为空)</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tp == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n<li><p><code>isFull</code> 操作(判断栈是否为满)</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isFull</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tp == N;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n<li><p><code>size</code> 操作(栈的大小)</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n<li><p><code>top</code> 操作(返回栈顶元素的引用)</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stk[tp];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n<li><p><code>clear</code> 操作(清空栈)</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    tp = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ol>\r\n<h4 id=\"stl-实现\"><code>STL</code> 实现</h4>\r\n<p>使用前，必须加上头文件 <code>#include &lt;stack&gt;</code> &amp;\r\n标准名字空间 <code>using std::stack;</code></p>\r\n<p><strong>示例代码：</strong></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> std::stack;</span><br><span class=\"line\">stack&lt;<span class=\"type\">int</span>&gt; stk;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x = <span class=\"number\">10</span>; <span class=\"comment\">// 待入栈元素</span></span><br><span class=\"line\">    stk.<span class=\"built_in\">push</span>(x); <span class=\"comment\">// 入栈操作</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;top=%d size=%d\\n&quot;</span>, stk.<span class=\"built_in\">top</span>(), stk.<span class=\"built_in\">size</span>()); <span class=\"comment\">// 返回栈顶指针的引用 &amp; 栈的大小</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;isEmpty=%d\\n&quot;</span>, stk.<span class=\"built_in\">empty</span>()); <span class=\"comment\">// 返回栈是否为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!stk.<span class=\"built_in\">empty</span>()) stk.<span class=\"built_in\">pop</span>(); <span class=\"comment\">// 出栈操作</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;size=%d\\n&quot;</span>, stk.<span class=\"built_in\">size</span>()); <span class=\"comment\">// 返回栈的大小 *PS: 此处不能输出 stk.top() !</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;isEmpty=%d\\n&quot;</span>, stk.<span class=\"built_in\">empty</span>()); <span class=\"comment\">// 返回栈是否为空</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>以上函数的时间复杂度均为 <span\r\nclass=\"math inline\">\\(O(1)\\)</span></p>\r\n<p>值得注意的是，<code>STL</code>\r\n并没有清空栈的函数，所以，如果想要清空栈，只能这么写：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (stk.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">    stk.<span class=\"built_in\">pop</span>();</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"栈的应用\">栈的应用</h3>\r\n<h4 id=\"括号配对问题-easy\">括号配对问题 / Easy</h4>\r\n<p>假设表达式中允许包含两种括号：圆括号和方括号，其嵌套的顺序随意，如 (\r\n[ ] ( ) ) 或 [ ( [ ] [ ] ) ] 等为正确的匹配，[ ( ] ) 或( [ ] ( ) 或 ( (\r\n) ) ）均为错误的匹配。</p>\r\n<p>现在的问题是，要求检验一个给定表达式中的括弧是否正确匹配？</p>\r\n<p>输入一个只包含圆括号和方括号的字符串，判断字符串中的括号是否匹配，匹配就输出<code>OK</code>\r\n，不匹配就输出<code>Wrong</code>。</p>\r\n<h4 id=\"题解\">题解</h4>\r\n<p>这题是最简单的括号配对问题。伪代码如下：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (左括号) &#123;</span><br><span class=\"line\">\t入栈;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&#x27;)&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (栈顶不为<span class=\"string\">&#x27;(&#x27;</span>)</span><br><span class=\"line\">        结束程序;</span><br><span class=\"line\">    出栈;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&#x27;]&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (栈顶不为<span class=\"string\">&#x27;[&#x27;</span>)</span><br><span class=\"line\">        结束程序;</span><br><span class=\"line\">    出栈;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>C++ 代码：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> tp;</span><br><span class=\"line\"><span class=\"type\">char</span> s[N], stk[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, s);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; s[i]; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s[i]==<span class=\"string\">&#x27;(&#x27;</span> <span class=\"keyword\">or</span> s[i]==<span class=\"string\">&#x27;[&#x27;</span>) &#123;</span><br><span class=\"line\">            stk[++tp] = s[i];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;)&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (stk[tp] != <span class=\"string\">&#x27;(&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Wrong&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tp--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;]&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (stk[tp] != <span class=\"string\">&#x27;[&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Wrong&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tp--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tp) <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Wrong&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;OK&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"括号配对问题-difficult\">括号配对问题 / Difficult</h4>\r\n<p>字符串中只含有括号\r\n(),[],&lt;&gt;,{},判断输入的字符串中括号是否匹配。如果括号有互相包含的形式，从内到外必须是&lt;&gt;,(),[],{}，例如。输入:\r\n[()] 输出 <code>YES</code>，而输入([])，([)]都应该输出\r\n<code>NO</code>。</p>\r\n<p>PS. 本题为多组输入输出</p>\r\n<h4 id=\"题解-1\">题解</h4>\r\n<p>本题比上题难，主要难在两点：</p>\r\n<ol type=\"1\">\r\n<li>括号种类 <span class=\"math inline\">\\(2\\)</span> 个增至 ==<span\r\nclass=\"math inline\">\\(4\\)</span>== 个</li>\r\n<li>引入==优先级==</li>\r\n</ol>\r\n<p>其中，第一个难点可以通过定义字符串解决，第二个难点可以通过函数解决。题目整体难度不算大。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">260</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n, stk[N] = &#123;<span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">string s, priority = <span class=\"string\">&quot;&lt;&gt;()[]&#123;&#125;&quot;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_pre</span><span class=\"params\">(<span class=\"type\">char</span> c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; priority.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (priority[i] == c)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>); cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> tp = <span class=\"number\">0</span>;</span><br><span class=\"line\">        cin &gt;&gt; s;</span><br><span class=\"line\">        s = <span class=\"string\">&#x27; &#x27;</span> + s;</span><br><span class=\"line\">        <span class=\"type\">int</span> i, pre, len = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= len; i++) &#123;</span><br><span class=\"line\">            pre = <span class=\"built_in\">get_pre</span>(s[i]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((pre &amp; <span class=\"number\">1</span>) == <span class=\"literal\">false</span>) &#123; <span class=\"comment\">// 左括号</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (stk[tp] &gt; pre) &#123;</span><br><span class=\"line\">                    stk[++tp] = pre + <span class=\"number\">1</span>; <span class=\"comment\">// 压入右括号(技巧)</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 优先级错误</span></span><br><span class=\"line\">                    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;NO&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (stk[tp] != pre) &#123; <span class=\"comment\">// 括号不匹配</span></span><br><span class=\"line\">                    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;NO&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 弹栈</span></span><br><span class=\"line\">                    tp--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; len) <span class=\"keyword\">continue</span>; <span class=\"comment\">// 已经 puts(&quot;NO&quot;);</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tp != <span class=\"number\">1</span>) <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;NO&quot;</span>); <span class=\"comment\">// 有多余括号</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;YES&quot;</span>); <span class=\"comment\">// 完全匹配且优先级正确</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"简易计算器\">简易计算器</h4>\r\n<p>小明在你的帮助下，破密了Ferrari设的密码门，正要往前走，突然又出现了一个密码门，门上有一个算式，其中只有“(”，“)”，“0-9”，“+”，“-”，“*”，“/”，“^”，求出的值就是密码。小明数学学得不好，还需你帮他的忙。(“/”用整数除法，\"^\"是幂运算，<code>2^3</code>\r\n为 8)</p>\r\n<p>PS. 输入保证合法</p>\r\n<h4 id=\"题解-2\">题解</h4>\r\n<p>读者可以先尝试这道题：<a\r\nhref=\"https://www.luogu.com.cn/problem/P1981\">洛谷_P1981 [NOIP2013\r\n普及组] 表达式求值</a></p>\r\n<p>本题是⌈表达式求值⌋的进阶版，具有一定的难度。</p>\r\n<p>这题中，有如下运算符：<code>(</code>，<code>)</code>，<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>^</code>。由幼儿园知识易得，括号的运算优先级是最高的。所以，当我们遇到右括号时，就意味着从与它配对的左括号到它没有一个优先级比它高，这样就可以心安理得地弹栈并计算了。</p>\r\n<p>那如果遇到了运算符呢？同理，不停弹栈并计算，直至栈顶运算符优先级比它高为止。</p>\r\n<p>本题核心思想伪代码如下：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (左括号) &#123;</span><br><span class=\"line\">    将左括号压进符号栈;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (右括号) &#123;</span><br><span class=\"line\">    弹栈并计算;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (数) &#123;</span><br><span class=\"line\">    将其压进数字栈;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 即除括号外其他运算符</span></span><br><span class=\"line\">    弹栈直至栈顶运算符的优先级高于当前运算符的优先级;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>C++ 代码：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">39</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> s[N] = <span class=\"string\">&quot;(&quot;</span>, stkc[N];</span><br><span class=\"line\"><span class=\"type\">int</span> stk[N], tp, tpc;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title\">pre</span><span class=\"params\">(<span class=\"type\">char</span> op)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (op==<span class=\"string\">&#x27;+&#x27;</span> <span class=\"keyword\">or</span> op==<span class=\"string\">&#x27;-&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (op==<span class=\"string\">&#x27;*&#x27;</span> <span class=\"keyword\">or</span> op==<span class=\"string\">&#x27;/&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (op==<span class=\"string\">&#x27;^&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">calc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = stk[tp--], y = stk[tp--];</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (stkc[tpc--]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>: y += x; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>: y -= x; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>: y *= x; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;/&#x27;</span>: y /= x; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;^&#x27;</span>: y = <span class=\"built_in\">pow</span>(y, x); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stk[++tp] = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"type\">int</span> &amp;cur)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">bool</span> neg = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> c = s[cur];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;-&#x27;</span>) neg = <span class=\"literal\">true</span>, ++cur;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">isdigit</span>(s[cur])) ans = ans * <span class=\"number\">10</span> + s[cur++] - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">    cur--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> neg ? -ans : ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, s + <span class=\"number\">1</span>);</span><br><span class=\"line\">    s[<span class=\"built_in\">strlen</span>(s)] = <span class=\"string\">&#x27;)&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; s[i]; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;(&#x27;</span>) &#123;</span><br><span class=\"line\">            stkc[++tpc] = <span class=\"string\">&#x27;(&#x27;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;)&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (stkc[tpc] != <span class=\"string\">&#x27;(&#x27;</span>) <span class=\"built_in\">calc</span>();</span><br><span class=\"line\">            tpc--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">isdigit</span>(s[i]) <span class=\"built_in\">or</span> (s[i]==<span class=\"string\">&#x27;-&#x27;</span> <span class=\"keyword\">and</span> s[i<span class=\"number\">-1</span>]==<span class=\"string\">&#x27;(&#x27;</span>)) &#123; <span class=\"comment\">// 特别注意处理负数</span></span><br><span class=\"line\">            stk[++tp] = <span class=\"built_in\">read</span>(i);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"built_in\">pre</span>(s[i]) &lt;= <span class=\"built_in\">pre</span>(stkc[tpc])) <span class=\"built_in\">calc</span>();</span><br><span class=\"line\">            stkc[++tpc] = s[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, stk[tp]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"逆波兰表达式\">逆波兰表达式</h4>\r\n<p>逆波兰记法中，操作符置于操作数的后面。例如表达“三加四”时，写作“3 4\r\n+”，而不是“3 +\r\n4”。如果有多个操作符，操作符置于第二个操作数的后面，所以常规中缀记法的“3\r\n- 4 + 5”在逆波兰记法中写作3 4 - 5 +”：先3减去4，再加上5。</p>\r\n<p>使用逆波兰记法的一个好处是不需要使用括号。</p>\r\n<p>PS. 保证式子正确，运算符只包括\r\n加<code>+</code>、减<code>-</code>、乘<code>*</code>、除<code>/</code></p>\r\n<p>PS. 输出一个浮点数，保留两位有效数字</p>\r\n<h4 id=\"题解-3\">题解</h4>\r\n<p>按说这题比上题简单，因为没有什么乱七八糟的优先级问题。例如\r\n<code>1 2 + 3 *</code>，当栈中有已经两个数，且当前字符为运算符，就\r\ncalc，否则继续压栈。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">stack &lt;<span class=\"type\">double</span>&gt; stk;</span><br><span class=\"line\"><span class=\"type\">char</span> s[<span class=\"number\">1009</span>], ch[<span class=\"number\">109</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">calc</span><span class=\"params\">(<span class=\"type\">char</span> c)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">double</span> x = stk.<span class=\"built_in\">top</span>(); stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t<span class=\"type\">double</span> y = stk.<span class=\"built_in\">top</span>(); stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> (c) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>: y += x; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>: y -= x; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>: y *= x; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;/&#x27;</span>: y /= x; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstk.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cur = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tcin.<span class=\"built_in\">getline</span>(s, <span class=\"number\">1009</span>);</span><br><span class=\"line\">\ts[<span class=\"built_in\">strlen</span>(s)] = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; s[i]; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27; &#x27;</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> ((s[i] &gt;= <span class=\"string\">&#x27;0&#x27;</span> <span class=\"keyword\">and</span> s[i] &lt;= <span class=\"string\">&#x27;9&#x27;</span>) <span class=\"keyword\">or</span> s[i] == <span class=\"string\">&#x27;.&#x27;</span> <span class=\"built_in\">or</span> (s[i] == <span class=\"string\">&#x27;-&#x27;</span> <span class=\"keyword\">and</span> <span class=\"built_in\">isdigit</span>(s[i+<span class=\"number\">1</span>])))</span><br><span class=\"line\">            ch[cur++] = s[i++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">isdigit</span>(ch[<span class=\"number\">0</span>]) <span class=\"keyword\">or</span> ch[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;-&#x27;</span>) stk.<span class=\"built_in\">push</span>(<span class=\"built_in\">atof</span>(ch));</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">calc</span>(s[i]);</span><br><span class=\"line\">\t\tcur = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(ch, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(ch));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.2f&quot;</span>, stk.<span class=\"built_in\">top</span>());</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>PS. 这个代码是以前写的，码风与其他代码不太一致，敬请谅解。</p>\r\n<h4 id=\"拓展-系统栈\">拓展 / 系统栈</h4>\r\n<p>利用递归写一个 <span class=\"math inline\">\\(10\\)</span> 进制转 <span\r\nclass=\"math inline\">\\(2\\)</span> 进制的程序。</p>\r\n<p>这个程序大家都会写：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">trans</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">trans</span>(n &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, n &amp; <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>模拟将数 <span class=\"math inline\">\\(10\\)</span> 转为 <span\r\nclass=\"math inline\">\\(2\\)</span> 进制的过程：</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2022/05/17/bBdC19Mfqza6nUK.png\"\r\nalt=\"ten2two\" />\r\n<figcaption aria-hidden=\"true\">ten2two</figcaption>\r\n</figure>\r\n<p>由上图，递归与回溯的过程其实就是压栈与弹栈。所以所有的 <span\r\nclass=\"math inline\">\\(DFS\\)</span> 都可以用栈来解决。</p>\r\n<p>下一篇文章将讲解 <span class=\"math inline\">\\(DFS\\)</span></p>\r\n","categories":["专题"],"tags":["C++","数据结构","栈"]},{"title":"【专题】深搜算法","url":"/2022/06/14/topic-dfs/","content":"<h3 id=\"链接区\"><a href=\"#链接区\" class=\"headerlink\" title=\"链接区\"></a>链接区</h3><p>安利一发我的博客：<a href=\"https://willhou936.github.io/\">WillHou’s Blog</a></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>之所以要把深搜(递归)放在栈后面写，是因为深搜的本质就是一个栈。</p>\n<blockquote>\n<p>当我们递归地实现 <code>DFS</code> 时，似乎不需要使用任何栈。但实际上，我们使用的是由系统提供的隐式栈，也称为调用栈（Call Stack）。—— CSDN 大佬 <a href=\"https://qingmei2.blog.csdn.net/\">却把清梅嗅</a></p>\n</blockquote>\n<p>深搜的优点：</p>\n<ul>\n<li>代码量小</li>\n<li>可读性强</li>\n<li>更容易实现</li>\n</ul>\n<p>深搜的缺点：</p>\n<ul>\n<li>如果深度太高，容易发生栈溢出</li>\n<li>容易超时</li>\n</ul>\n<p>深搜的使用场景：</p>\n<ul>\n<li>在图论中大量使用（实际上深搜的概念就是基于图论的，只不过我们通常把深搜的概念广义化）</li>\n<li><del>当你实在做不出来时骗分</del></li>\n</ul>\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>DFS 全称是 <a href=\"https://en.wikipedia.org/wiki/Depth-first_search\">Depth First Search</a>，中文名是深度优先搜索，是一种用于遍历或搜索树或图的算法。所谓深度优先，就是说每次都尝试向更深的节点走。DFS 常常用来指代用递归函数实现的搜索，但实际上两者并不一样。</p>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><p>先来一个不是这么正经的，感受一下何为递归。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">tellStory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">puts</span>(<span class=\"string\">&quot;从前有座山，山上有座庙，庙里有个老和尚在讲故事，讲的故事是：&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">tellStory</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">tellStory</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个程序永远无法终止，会不停的输出“从前有座山，山上有座庙，庙里有个老和尚在讲故事，讲的故事是：”。</p>\n<p>当然，这样的程序完全没有用处。所以，我们尝试对它加入次数限制：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">tellStory</span><span class=\"params\">(<span class=\"type\">int</span> times)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!times) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t<span class=\"built_in\">puts</span>(<span class=\"string\">&quot;从前有座山，山上有座庙，庙里有个老和尚在讲故事，讲的故事是：&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">tellStory</span>(times<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">tellStory</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，我们限制它只输出十次。那如果我也想看到这是第几次输出呢？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">tellStory</span><span class=\"params\">(<span class=\"type\">int</span> times)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!times) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d. 从前有座山，山上有座庙，庙里有个老和尚在讲故事，讲的故事是：\\n&quot;</span>, <span class=\"number\">11</span> - times);</span><br><span class=\"line\">    <span class=\"built_in\">tellStory</span>(times<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">tellStory</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，我们基本得到了一个递归(DFS) 的模板（伪代码）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> argument)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (结束条件满足) &#123;</span><br><span class=\"line\">        如果有，就操作;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    当层要做的事情;</span><br><span class=\"line\">    递归到下一层;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h3><h4 id=\"斐波那契数列\"><a href=\"#斐波那契数列\" class=\"headerlink\" title=\"斐波那契数列\"></a>斐波那契数列</h4><p>概括：求斐波那契数列的第 $n$ 项，第一项为 $0$，第二项为 $1$。</p>\n<p>关于斐波那契数列的定义，请出门右转到<a href=\"https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97\">百度百科</a>。</p>\n<p>这是一道典型的递归题，可以直接套用上面的模板。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> cnt = <span class=\"number\">2</span>, temp;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fbi</span><span class=\"params\">(<span class=\"type\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (m &lt;= <span class=\"number\">2</span>) <span class=\"keyword\">return</span> m - <span class=\"number\">1</span>; <span class=\"comment\">// 这句是用了点技巧，请手算推之。</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">fbi</span>(m<span class=\"number\">-1</span>) + <span class=\"built_in\">fbi</span>(m<span class=\"number\">-2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, <span class=\"built_in\">fbi</span>(n));</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"最大公约数\"><a href=\"#最大公约数\" class=\"headerlink\" title=\"最大公约数\"></a>最大公约数</h4><p>概括：求两个正整数 $a$ 和 $b$ 的最大公约数。</p>\n<p>关于最大公约数的定义，请出门右转到<a href=\"https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0\">百度百科</a>。</p>\n<p>这是众所周知的辗转相除法，也是入门必备小技巧之一。</p>\n<p>关于辗转相除法的原理，请出门右转到<a href=\"https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95\">百度百科</a></p>\n<p>看完百度百科的你一定发现了，这其实就是递归的过程。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> b==<span class=\"number\">0</span> ? a : <span class=\"built_in\">gcd</span>(b, a%b); &#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">这看上去不符合递归(深搜)的模板，但当你整理成这样后：</span></span><br><span class=\"line\"><span class=\"comment\">int gcd(int a, int b) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">\tif (b == 0) return a;</span></span><br><span class=\"line\"><span class=\"comment\">\treturn gcd(b, a%b);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">你就会发现这还是一模一样的。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> m, n;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;gcd=%d&quot;</span>, <span class=\"built_in\">gcd</span>(m, n));</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"全排列问题\"><a href=\"#全排列问题\" class=\"headerlink\" title=\"全排列问题\"></a>全排列问题</h4><p>概括：给定一个由不同的小写字母组成的字符串，输出这个字符串的所有全排列。 输入已经按照字典序整理好。</p>\n<p>关于全排列的定义，请出门右转到<a href=\"https://baike.baidu.com/item/%E5%85%A8%E6%8E%92%E5%88%97\">百度百科</a>。</p>\n<p>这道题是进阶的 DFS。还包括了搜索中重要的技巧：回溯法。如果说递归(DFS)是一种“不撞南墙不回头”的算法，那么回溯法就是让他回头。比如我们要达到一个目的地，但是我们面前有三条路，并且只有一条路是可以到达目的地的，因此我们需要一条一条去尝试，如果不行的话就得回到原点，选择下一条路进行尝试，这种就叫做回溯。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/833882f458c7c32934248f6db761e086.png\" alt=\"\"></p>\n<p>其工作原理为：</p>\n<ol>\n<li>构造空间树；</li>\n<li>进行遍历；</li>\n<li>如遇到边界条件，即不再向下搜索，转而搜索另一条链；</li>\n<li>达到目标条件，输出结果。</li>\n</ol>\n<p>其模板为（伪代码）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> argument)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (结束条件满足) &#123;</span><br><span class=\"line\">        如果有，就操作;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    当层要做的事情;</span><br><span class=\"line\">    标记为已访问;</span><br><span class=\"line\">    递归到下一层;</span><br><span class=\"line\">    标记为未访问;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码灵活性强，没有特别绝对的模板，需要 OIer 灵机应变。</p>\n<p>关于这题的代码，请出门调头到 <a href=\"https://blog.csdn.net/WillHou/article/details/125145801\">CSDN</a> 或 <a href=\"https://willhou936.github.io/2022/06/26/solution-permutation/\">我的博客</a></p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><ol>\n<li>OI-Wiki: <a href=\"https://oi-wiki.org/\">https://oi-wiki.org/</a></li>\n</ol>\n","categories":["专题"],"tags":["C++","深搜"]},{"title":"【专题】经典DP问题","url":"/2022/06/14/topic-dp_classic_1/","content":"<h3 id=\"对抗赛compete\">1. 对抗赛(compete)</h3>\r\n<h4 id=\"题目描述\">题目描述</h4>\r\n<p>程序设计对抗赛设有 <span class=\"math inline\">\\(N\\)</span> (<span\r\nclass=\"math inline\">\\(0\\lt N\\lt\r\n50\\)</span>的整数)个价值互不相同的奖品，每个奖品的价值分别为 <span\r\nclass=\"math inline\">\\(S_1，S_2，S_3\\dots S_n\\)</span>(均为不超过 <span\r\nclass=\"math inline\">\\(100\\)</span>\r\n的正整数)。现将它们分给甲乙两队，为了使得甲乙两队得到相同价值的奖品，必须将这\r\n<span class=\"math inline\">\\(N\\)</span> 个奖品分成总价值相等的两组。</p>\r\n<p>编程要求：对给定 <span class=\"math inline\">\\(N\\)</span> 及 <span\r\nclass=\"math inline\">\\(N\\)</span> 个奖品的价值，求出将这 <span\r\nclass=\"math inline\">\\(N\\)</span>\r\n个奖品分成价值相等的两组，共有多少种分法？</p>\r\n<p>例如：<span class=\"math inline\">\\(N = 5，S_1，S_2，S_3\\dots\r\nS_n\\)</span> 分别为 <span\r\nclass=\"math inline\">\\(1，3，5，8，9\\)</span></p>\r\n<p>则可分为 <span class=\"math inline\">\\(\\{1，3，9\\}\\)</span> 与 <span\r\nclass=\"math inline\">\\(\\{5，8\\}\\)</span></p>\r\n<p>仅有 <span class=\"math inline\">\\(1\\)</span> 种分法；</p>\r\n<p>例如：<span class=\"math inline\">\\(N = 7，S_1，S_2，S_3\\dots\r\nS_n\\)</span> 分别为 <span\r\nclass=\"math inline\">\\(1，2，3，4，5，6，7\\)</span></p>\r\n<p>则可分为：</p>\r\n<p><span class=\"math inline\">\\(\\{1,6,7\\}\\)</span> 与 <span\r\nclass=\"math inline\">\\(\\{2,3,4,5\\}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\{2,5,7\\}\\)</span> 与 <span\r\nclass=\"math inline\">\\(\\{1,3,4,6\\}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\{3,4,7\\}\\)</span> 与 <span\r\nclass=\"math inline\">\\(\\{1,2,5,6\\}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\{1,2,4,7\\}\\)</span> 与 <span\r\nclass=\"math inline\">\\(\\{3,5,6\\}\\)</span></p>\r\n<p>有 <span class=\"math inline\">\\(4\\)</span> 种分法。</p>\r\n<h4 id=\"输入格式\">输入格式</h4>\r\n<p>输入包含 <span class=\"math inline\">\\(N\\)</span> 及 <span\r\nclass=\"math inline\">\\(S_1，S_2，S_3\\dots\r\nS_n\\)</span>。（每两个相邻的数据之间有一个空格隔开）。</p>\r\n<h4 id=\"输出格式\">输出格式</h4>\r\n<p>输出包含一个整数，表示多少种分法的答案，数据若无解，则输出 <span\r\nclass=\"math inline\">\\(0\\)</span>。</p>\r\n<h4 id=\"解法分析\">解法分析</h4>\r\n<p>这题数据范围很小，所以写 dfs 都可以 AC。先上最好理解的 dfs:</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">59</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n, sum, ans, a[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> cur, <span class=\"type\">int</span> sub)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur &gt; (sum &gt;&gt; <span class=\"number\">1</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur == (sum &gt;&gt; <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        ans++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = sub; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(cur+a[i], i+<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, a + i), sum += a[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sum &amp; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(a[<span class=\"number\">1</span>], <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, ans);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>dp 解法：不难看出，此题是一道 <strong>01背包</strong>\r\n的求方案数类问题。每个奖品有<strong>选</strong>或者<strong>不选</strong>两种操作。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">5007</span>, M = <span class=\"number\">50</span>;</span><br><span class=\"line\"><span class=\"comment\">// f[i] 表示当 sum=i 时有多少种分法</span></span><br><span class=\"line\"><span class=\"type\">int</span> f[N], a[M];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n, sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, a + i), sum += a[i];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (sum &amp; <span class=\"number\">1</span>) &#123; <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;0&quot;</span>); <span class=\"keyword\">return</span> <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">\tsum &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">\tf[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = sum; j &gt;= a[i]; j--)</span><br><span class=\"line\">\t\t\tf[j] += f[j-a[i]];</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, f[sum]&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"演讲大厅安排hall\">2. 演讲大厅安排(hall)</h3>\r\n<h4 id=\"题目描述-1\">题目描述</h4>\r\n<p>有一个演讲大厅需要我们管理，演讲者们事先定好了需要演讲的起始时间和中止时间。我们想让演讲大厅得到最大可能的使用。我们要接受一些预定而拒绝其他的预定，目标是使演讲者使用大厅的时间最长。假设在某一时刻一个演讲结束，另一个演讲就可以立即开始。</p>\r\n<p>【编程任务】</p>\r\n<ol type=\"1\">\r\n<li><p>输入演讲者的申请。</p></li>\r\n<li><p>计算演讲大厅最大可能的使用时间。</p></li>\r\n<li><p>将结果输出。</p></li>\r\n</ol>\r\n<h4 id=\"输入格式-1\">输入格式</h4>\r\n<p>输入第一行为一个整数 <span\r\nclass=\"math inline\">\\(N(N≤5000)\\)</span>，表示申请的数目。</p>\r\n<p>以下 <span class=\"math inline\">\\(n\\)</span> 行每行包含两个整数 <span\r\nclass=\"math inline\">\\(p,k(1 ≤ p &lt; k ≤\r\n30000)\\)</span>，表示这个申请的起始时间和中止时间。</p>\r\n<h4 id=\"输出格式-1\">输出格式</h4>\r\n<p>输出包含一个整数，表示大厅最大可能的使用时间。</p>\r\n<h4 id=\"解法分析-1\">解法分析</h4>\r\n<p><del>首先感谢出题人，latex用的少</del></p>\r\n<p><strong>这题是一道经典的<a id=\"hall\">线段覆盖问题</a>。</strong>这种问题的固定解法是：</p>\r\n<ol type=\"1\">\r\n<li>通过结构体记录每一段线段的<strong>头</strong>和<strong>尾</strong></li>\r\n<li>按照<strong>尾</strong>从小到大排序</li>\r\n<li>使用 <strong>01背包</strong> 的解法解即可</li>\r\n</ol>\r\n<p>代码如下：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1007</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> f[N], a[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n, sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, a + i), sum += a[i];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (sum &amp; <span class=\"number\">1</span>) &#123; <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;0&quot;</span>); <span class=\"keyword\">return</span> <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">\tsum &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">\tf[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = sum; j &gt;= a[i]; j--)</span><br><span class=\"line\">\t\t\tf[j] += f[j-a[i]];</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, f[sum]&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"火车票railway\">3. 火车票(railway)</h3>\r\n<h4 id=\"题目描述-2\">题目描述</h4>\r\n<p>从 Ekaterinburg 到 Sverdlovsk\r\n的火车线路上有若干个站点。这条线路可以近似的表示为一条线段，火车站就是线段上的点。线路始于\r\nEkaterinburg ，终于 Sverdlovsk。Ekaterinburg 被标号为 <span\r\nclass=\"math inline\">\\(1\\)</span>，Sverdlovsk 被标号为 <span\r\nclass=\"math inline\">\\(n\\)</span>。（<span\r\nclass=\"math inline\">\\(n\\)</span> 为整条线路上的站点数）</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2022/04/28/mJtfTwPcKzCvS9V.png\"\r\nalt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>线路上的任意两个站点间的直达票价是由它们间的距离决定的，票价根据以下规则制定：</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2022/04/28/goQezMNjHvAlypf.png\"\r\nalt=\"f3b685001d.png\" />\r\n<figcaption aria-hidden=\"true\">f3b685001d.png</figcaption>\r\n</figure>\r\n<p>如果两站的间距超过 <span\r\nclass=\"math inline\">\\(L_3\\)</span>，则无直达车票。所以有时可能有必要买多张票，通过转车的方式，从一个站到达另一个站。</p>\r\n<p>例如，在上面的图中，有 <span class=\"math inline\">\\(7\\)</span>\r\n个站点。<span class=\"math inline\">\\(2\\)</span> 号站点到 <span\r\nclass=\"math inline\">\\(6\\)</span> 号站点的距离超过 <span\r\nclass=\"math inline\">\\(L_3\\)</span>，不能买直达票。存在若干种中转的方法，其中的一种是买两张票：先花费\r\n<span class=\"math inline\">\\(C_2\\)</span> 从 <span\r\nclass=\"math inline\">\\(2\\)</span> 号站到达 <span\r\nclass=\"math inline\">\\(3\\)</span> 号站，然后花费 <span\r\nclass=\"math inline\">\\(C_3\\)</span> 从 <span\r\nclass=\"math inline\">\\(3\\)</span> 号站到 <span\r\nclass=\"math inline\">\\(6\\)</span> 号站，一种花费 <span\r\nclass=\"math inline\">\\(C_2+C_3\\)</span>。</p>\r\n<p>你的任务是，找出一种最经济的中转方案。</p>\r\n<h4 id=\"输入格式-2\">输入格式</h4>\r\n<p>第一行 <span class=\"math inline\">\\(6\\)</span> 个整数 <span\r\nclass=\"math inline\">\\(L_1, L_2, L_3, C_1, C_2, C_3\\ (1\\le L_1\\lt L_2\\lt\r\nL_3\\le 10^9, 1\\le C_1\\lt C_2\\lt C3\\le\r\n10^9)\\)</span>，中间用空格分隔。</p>\r\n<p>第二行一个整数 <span class=\"math inline\">\\(n(2\\le n\\le\r\n100)\\)</span>，表示线路上的车站数。</p>\r\n<p>第三行两个整数 <span class=\"math inline\">\\(s\\)</span> 和 <span\r\nclass=\"math inline\">\\(t\\)</span>，分别是起点和终点的编号。注意：<span\r\nclass=\"math inline\">\\(s\\)</span> 不一定小于 <span\r\nclass=\"math inline\">\\(t\\)</span>。</p>\r\n<p>以下的 <span class=\"math inline\">\\(n-1\\)</span> 行，按据 Ekaterinburg\r\n远近，每行描述了一个车站的位置。它包含一个整数，表示该车站距\r\nEkaterinburg 的距离。</p>\r\n<p>任意两个车站的距离不超过 <span\r\nclass=\"math inline\">\\(10^9\\)</span>，任意两个相邻的车站的距离不超过\r\n<span class=\"math inline\">\\(L_3\\)</span>。</p>\r\n<h4 id=\"输出格式-2\">输出格式</h4>\r\n<p>一个整数，表示从给定的一个站到给定的另一个站的最小花费。</p>\r\n<h4 id=\"解法分析-2\">解法分析</h4>\r\n<p>这道题是一道典型的 <a id=\"qujiandp\"><strong>区间DP</strong></a>\r\n问题（可以把车站之间的距离看成一个物品）。</p>\r\n<p>区间 DP 套路：</p>\r\n<ol type=\"1\">\r\n<li>定状态：<code>f[i][j]</code>表示从 <code>i~j</code>\r\n的区间（本题中表示从第 <code>i</code> 个车站到第 <code>j</code>\r\n个车站最少花费多少钱）。</li>\r\n<li>状态转移方程：<code>f[i][j] = min(f[i][k] + f[k][j])</code></li>\r\n</ol>\r\n<p>区间 DP 模式：</p>\r\n<ol type=\"1\">\r\n<li><p>从小区间推至大区间（核心）</p></li>\r\n<li><p>循环伪代码：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (区间长度) <span class=\"comment\">// 通常循环变量为 i</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (起点) &#123; <span class=\"comment\">// 通常循环变量为 j</span></span><br><span class=\"line\">        终点 = 起点 + 区间长度 - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (断点) <span class=\"comment\">// 通常循环变量为 k</span></span><br><span class=\"line\">            状态转移方程;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\r\n</ol>\r\n<p>对于上面的代码，<span class=\"math inline\">\\(i,\\ j,\\ k\\)</span>\r\n必须满足以下条件： <span class=\"math display\">\\[\r\n\\begin{cases}\r\nk+1&gt;i \\\\\r\n[i, j] 的范围大于 [i, k],[k+1, j],因此要从小区间枚举到大区间\r\n\\end{cases}\r\n\\]</span> 由于在一般的 区间DP 的最小区间是 <span\r\nclass=\"math inline\">\\(f[i][i]\\)</span>，所以通常会将其初始化(例如\r\n<a href=\"#hebingshizi\">合并石子</a>)。当然，在一些 区间DP\r\n的变式中，不一定这样初始化(例如本题)。</p>\r\n<p>本题代码：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> LL;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">109</span>, INF = <span class=\"number\">0X3F3F3F3F3F3F3F3F</span>;</span><br><span class=\"line\">LL f[N][N], L[N], C[N], loc[N];</span><br><span class=\"line\"><span class=\"function\">LL <span class=\"title\">calc</span><span class=\"params\">(LL s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">3</span>; i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s &lt;= L[i]) <span class=\"keyword\">return</span> C[i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> INF;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">3</span>; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, L + i);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">3</span>; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>, C + i);</span><br><span class=\"line\">\t<span class=\"type\">int</span> n, s, t;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;n, &amp;s, &amp;t);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f, <span class=\"number\">0x3F</span>, <span class=\"keyword\">sizeof</span> f);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, loc + i);</span><br><span class=\"line\">\t\tf[i<span class=\"number\">-1</span>][i] = <span class=\"built_in\">calc</span>(loc[i] - loc[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (s &gt; t) std::<span class=\"built_in\">swap</span>(s, t);</span><br><span class=\"line\">\t<span class=\"comment\">// 区间 DP 第一层是枚举长度</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> d = <span class=\"number\">2</span>; d &lt;= n; d++)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 第二层枚举起点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i+d<span class=\"number\">-1</span> &lt;= n; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> j = i + d - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tf[i][j] = <span class=\"built_in\">calc</span>(loc[j] - loc[i]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = i+<span class=\"number\">1</span>; k &lt; j; k++)</span><br><span class=\"line\">\t\t\t\tf[i][j] = std::<span class=\"built_in\">min</span>(f[i][j], f[i][k]+f[k][j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>, f[s][t]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"单词的划分word\">4. 单词的划分(word)</h3>\r\n<h4 id=\"题目描述-3\">题目描述</h4>\r\n<p>有一个很长的由小写字母组成字符串。为了便于对这个字符串进行分析，需要将它划分成若干个部分，每个部分称为一个单词。出于减少分析量的目的，我们希望划分出的单词数越少越好。你就是来完成这一划分工作的。</p>\r\n<h4 id=\"输入格式-3\">输入格式</h4>\r\n<p>第 <span class=\"math inline\">\\(1\\)</span>\r\n行，一个字符串。（字符串的长度不超过 <span\r\nclass=\"math inline\">\\(100\\)</span>）</p>\r\n<p>第 <span class=\"math inline\">\\(2\\)</span> 行一个整数 <span\r\nclass=\"math inline\">\\(n\\)</span>，表示单词的个数。（<span\r\nclass=\"math inline\">\\(n&lt;=100\\)</span>）</p>\r\n<p>第 <span class=\"math inline\">\\(3\\sim n+2\\)</span>\r\n行，每行列出一个单词。</p>\r\n<h4 id=\"输出格式-3\">输出格式</h4>\r\n<p>一个整数，表示字符串可以被划分成的最少的单词数。</p>\r\n<h4 id=\"解法分析-3\">解法分析</h4>\r\n<p>这题是一道背包问题。把背包问题要素整理出来得：</p>\r\n<ol type=\"1\">\r\n<li>背包容量：字符串长度</li>\r\n<li>物品数：单词个数</li>\r\n<li>物品价值：单词内容</li>\r\n<li>物品体积：单词长度</li>\r\n<li>物品数量：undefined</li>\r\n</ol>\r\n<p>由此可以知道，本题是一道 <strong>01背包</strong></p>\r\n<p>代码：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> std::string;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">107</span>;</span><br><span class=\"line\">std::map &lt;string, <span class=\"type\">bool</span>&gt; mp;</span><br><span class=\"line\"><span class=\"type\">int</span> f[N], n;</span><br><span class=\"line\">string s, w;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f, <span class=\"number\">0x3F</span>, <span class=\"keyword\">sizeof</span> f);</span><br><span class=\"line\">\tstd::cin &gt;&gt; s &gt;&gt; n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstd::cin &gt;&gt; w;</span><br><span class=\"line\">\t\tmp[w] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mp[s.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>)]) f[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">unsigned</span> i = <span class=\"number\">1</span>; i &lt; s.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> len = i+<span class=\"number\">1</span>; len; len--)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tstring ss = s.<span class=\"built_in\">substr</span>(i+<span class=\"number\">1</span>-len, len);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (mp[ss] == <span class=\"literal\">false</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i+<span class=\"number\">1</span>-len == <span class=\"number\">0</span>) &#123; f[i] = <span class=\"number\">1</span>; <span class=\"keyword\">break</span>; &#125;</span><br><span class=\"line\">\t\t\tf[i] = std::<span class=\"built_in\">min</span>(f[i], f[i-len]+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\tstd::cout &lt;&lt; f[s.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"饥饿的牛hunger\">5. 饥饿的牛(hunger)</h3>\r\n<h4 id=\"题目描述-4\">题目描述</h4>\r\n<p>牛在饲料槽前排好了队。饲料槽依次用 <span\r\nclass=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(N(1\\le\r\nN\\le 2000)\\)</span>\r\n编号。每天晚上，一头幸运的牛根据约翰的规则，吃其中一些槽里的饲料。</p>\r\n<p>约翰提供 <span class=\"math inline\">\\(B\\)</span><em>B</em>\r\n个区间的清单。一个区间是一对整数 <span\r\nclass=\"math inline\">\\(start-end(1\\le start\\le end\\le\r\nN)\\)</span>，表示一些连续的饲料槽，比如 <span\r\nclass=\"math inline\">\\(1\\sim 3,7\\sim 8,3\\sim 4\\)</span>\r\n等等。牛可以任意选择区间，但是牛选择的区间不能有重叠。</p>\r\n<p>当然，牛希望自己能够吃得越多越好。给出一些区间，帮助这只牛找一些区间，使它能吃到最多的东西。</p>\r\n<p>在上面的例子中，<span class=\"math inline\">\\(1\\sim 3\\)</span> 和 <span\r\nclass=\"math inline\">\\(3\\sim 4\\)</span> 是重叠的；聪明的牛选择 <span\r\nclass=\"math inline\">\\(\\{1\\sim3，7\\sim 8\\}\\)</span>，这样可以吃到 <span\r\nclass=\"math inline\">\\(5\\)</span> 个槽里的东西。</p>\r\n<h4 id=\"输入格式-4\">输入格式</h4>\r\n<p>第 <span class=\"math inline\">\\(1\\)</span> 行，整数 <span\r\nclass=\"math inline\">\\(B(1\\le B\\le 1000)\\)</span>。</p>\r\n<p>第 <span class=\"math inline\">\\(2\\sim B+1\\)</span>\r\n行，每行两个整数，表示一个区间，较小的端点在前面。</p>\r\n<h4 id=\"输出格式-4\">输出格式</h4>\r\n<p>仅一个整数，表示最多能吃到多少个槽里的食物。</p>\r\n<h4 id=\"解法分析-4\">解法分析</h4>\r\n<p>这又是一道线段覆盖问题，分析见\r\n<a href=\"#hall\">演讲大厅安排(hall)</a></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2009</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> b, f[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> st, ed;</span><br><span class=\"line\">&#125; feed[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;b);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= b; i++)</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;feed[i].st, &amp;feed[i].ed);</span><br><span class=\"line\">    std::<span class=\"built_in\">sort</span>(feed + <span class=\"number\">1</span>, feed + b + <span class=\"number\">1</span>, [](<span class=\"type\">const</span> Node &amp;a, <span class=\"type\">const</span> Node &amp;b) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.ed&lt;b.ed <span class=\"built_in\">or</span> (a.ed==b.ed <span class=\"keyword\">and</span> a.st&lt;b.st);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"type\">int</span> m = feed[b].ed;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= b; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = m; j &gt;= feed[i].ed; j--)</span><br><span class=\"line\">            f[j] = std::<span class=\"built_in\">max</span>(f[j], f[feed[i].st<span class=\"number\">-1</span>] + feed[i].ed - feed[i].st + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// for (int j = 1; j &lt;= m; j++)</span></span><br><span class=\"line\">        <span class=\"comment\">//     printf(&quot;%d &quot;, f[j]);</span></span><br><span class=\"line\">        <span class=\"comment\">// puts(&quot;&quot;);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, f[m]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"数字游戏game\">6. 数字游戏(game)</h3>\r\n<h4 id=\"题目描述-5\">题目描述</h4>\r\n<p>丁丁最近沉迷于一个数字游戏。这个游戏看似简单，但丁丁在研究了许多天之后却发觉原来在简单的规则下想要赢得这个游戏并不那么容易。</p>\r\n<p>游戏是这样的，在你面前有一圈整数（一共 <span\r\nclass=\"math inline\">\\(n\\)</span> 个），你要按顺序将其分为 <span\r\nclass=\"math inline\">\\(m\\)</span> 个部分，各部分内的数字相加，相加所得的\r\n<span class=\"math inline\">\\(m\\)</span> 个结果对 <span\r\nclass=\"math inline\">\\(10\\)</span> 取模后再相乘，最终得到一个数 <span\r\nclass=\"math inline\">\\(k\\)</span>。游戏的要求是使你所得的 <span\r\nclass=\"math inline\">\\(k\\)</span> 最大或者最小。</p>\r\n<p>例如，对于下面这圈数字（<span\r\nclass=\"math inline\">\\(n=4,m=2\\)</span>）：</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2022/04/28/wYprJjBfLU7GuN8.png\"\r\nalt=\"1.png\" />\r\n<figcaption aria-hidden=\"true\">1.png</figcaption>\r\n</figure>\r\n<p>当要求最小值时， <span class=\"math display\">\\[\r\n((2−1)\\ mod\\ 10)×((4+3)\\ mod\\ 10)=1×7=7\r\n\\]</span> 要求最大值时，为 <span class=\"math display\">\\[\r\n((2+4+3)\\ mod\\ 10)×(−1\\ mod\\ 10)=9×9=81\r\n\\]</span> 特别值得注意的是，无论是负数还是正数，对 <span\r\nclass=\"math inline\">\\(10\\)</span> 取模的结果均为非负值。</p>\r\n<p>丁丁请你编写程序帮他赢得这个游戏。</p>\r\n<h4 id=\"输入格式-5\">输入格式</h4>\r\n<p>输入第一行有两个整数，<span class=\"math inline\">\\(n(1\\le n\\le\r\n50)\\)</span> 和 <span class=\"math inline\">\\(m(1\\le m\\le\r\n9)\\)</span>。</p>\r\n<p>以下 <span class=\"math inline\">\\(n\\)</span>\r\n行每行有一个整数，其绝对值不大于 <span\r\nclass=\"math inline\">\\(10^4\\)</span>，按顺序给出圈中的数字，首尾相接。</p>\r\n<h4 id=\"输出格式-5\">输出格式</h4>\r\n<p>输出有两行，各包含一个非负整数。第一行是你程序得到的最小值，第二行是最大值。</p>\r\n<h4 id=\"解法分析-5\">解法分析</h4>\r\n<p>遇到这种<a id=\"huanxindp\"><strong>环形区间DP</strong></a>时，我们采用<strong>破环成链</strong>的方法，即将链拷贝一份加在末尾</p>\r\n<p>例如：4 3 -1 2 -&gt; 4 3 -1 2 4 3 -1 2</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>1</th>\r\n<th>2</th>\r\n<th>3</th>\r\n<th>4</th>\r\n<th>5</th>\r\n<th>6</th>\r\n<th>7</th>\r\n<th>8</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>4</td>\r\n<td>3</td>\r\n<td>-1</td>\r\n<td>2</td>\r\n<td>4</td>\r\n<td>3</td>\r\n<td>-1</td>\r\n<td>2</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>长度最大为 N 的区间有 N 个，分别为\r\n<code>[1,n], [2,n+1], [3,n+2], ... ,[n,n+n-1]</code>。我们最终在这 N\r\n个情况中选择最优解。</p>\r\n<p>其他的都不解释了，代码里注释比较清楚，有问题可以留言。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">109</span>, INF = <span class=\"number\">0x3F3F3F3F</span>;</span><br><span class=\"line\"><span class=\"comment\">// f[i][j][z] 表示从 i 到 j 的部分，分成 z 份的最大值</span></span><br><span class=\"line\"><span class=\"comment\">// g[i][j][z] 表示从 i 到 j 的部分，分成 z 份的最小值</span></span><br><span class=\"line\"><span class=\"type\">int</span> f[N][N][<span class=\"number\">10</span>], g[N][N][<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> n, m;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(g, INF, <span class=\"keyword\">sizeof</span> g);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;f[i][i][<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"comment\">// 将所有的数全部转成大于等于0且小于等于10的整数</span></span><br><span class=\"line\">        f[i][i][<span class=\"number\">1</span>] = g[i][i][<span class=\"number\">1</span>] = (f[i][i][<span class=\"number\">1</span>]%<span class=\"number\">10</span> + <span class=\"number\">10</span>) % <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"comment\">// &quot;破环成链&quot;</span></span><br><span class=\"line\">        f[n+i][n+i][<span class=\"number\">1</span>] = g[n+i][n+i][<span class=\"number\">1</span>] = f[i][i][<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 求前缀和</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n+n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i+<span class=\"number\">1</span>; j &lt;= n+n; j++)</span><br><span class=\"line\">            g[i][j][<span class=\"number\">1</span>] = f[i][j][<span class=\"number\">1</span>] = (f[i][j<span class=\"number\">-1</span>][<span class=\"number\">1</span>] + f[j][j][<span class=\"number\">1</span>]) % <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> z = <span class=\"number\">2</span>; z &lt;= m; z++) <span class=\"comment\">// 枚举份数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) <span class=\"comment\">// 枚举左端点</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i+z<span class=\"number\">-1</span>; j &lt; i+n; j++) <span class=\"comment\">// 枚举右端点</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = i+z<span class=\"number\">-2</span>; k &lt; j; k++) &#123; <span class=\"comment\">// 枚举中间节点</span></span><br><span class=\"line\">                    g[i][j][z] = std::<span class=\"built_in\">min</span>(g[i][j][z], g[i][k][z<span class=\"number\">-1</span>] * g[k+<span class=\"number\">1</span>][j][<span class=\"number\">1</span>]);</span><br><span class=\"line\">                    f[i][j][z] = std::<span class=\"built_in\">max</span>(f[i][j][z], f[i][k][z<span class=\"number\">-1</span>] * f[k+<span class=\"number\">1</span>][j][<span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 求最大&amp;最小值</span></span><br><span class=\"line\">    <span class=\"type\">int</span> mx = <span class=\"number\">0</span>, mn = INF;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        mx = f[i][i+n<span class=\"number\">-1</span>][m]&gt;mx ? f[i][i+n<span class=\"number\">-1</span>][m] : mx;</span><br><span class=\"line\">        mn = g[i][i+n<span class=\"number\">-1</span>][m]&lt;mn ? g[i][i+n<span class=\"number\">-1</span>][m] : mn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n%d\\n&quot;</span>, mn, mx);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"能量项链energy\">7. 能量项链(energy)</h3>\r\n<h4 id=\"题目描述-6\">题目描述</h4>\r\n<p>在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有 <span\r\nclass=\"math inline\">\\(N\\)</span>\r\n颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为\r\n<span class=\"math inline\">\\(m\\)</span>，尾标记为 <span\r\nclass=\"math inline\">\\(r\\)</span>，后一颗能量珠的头标记为 <span\r\nclass=\"math inline\">\\(r\\)</span>，尾标记为 <span\r\nclass=\"math inline\">\\(n\\)</span>，则聚合后释放的能量为 <span\r\nclass=\"math inline\">\\(m\\ast r\\ast n\\)</span>\r\n（Mars单位），新产生的珠子的头标记为 <span\r\nclass=\"math inline\">\\(m\\)</span>，尾标记为 <span\r\nclass=\"math inline\">\\(n\\)</span>。</p>\r\n<p>需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。</p>\r\n<p>例如：设 <span class=\"math inline\">\\(N=4\\)</span>，<span\r\nclass=\"math inline\">\\(4\\)</span> 颗珠子的头标记与尾标记依次为 <span\r\nclass=\"math inline\">\\((2,3) (3,5) (5,10) (10,2)\\)</span>。我们用记号\r\n<span class=\"math inline\">\\(\\bigoplus\\)</span>\r\n表示两颗珠子的聚合操作，<span class=\"math inline\">\\((j\\bigoplus\r\nk)\\)</span> 表示第 <span class=\"math inline\">\\(j,k\\)</span>\r\n两颗珠子聚合后所释放的能量。则第 <span class=\"math inline\">\\(4,\r\n1\\)</span> 两颗珠子聚合后释放的能量为： <span class=\"math display\">\\[\r\n(4\\bigoplus1)=10\\times 2\\times 3=60\r\n\\]</span> 这一串项链可以得到最优值的一个聚合顺序所释放的总能量为 <span\r\nclass=\"math display\">\\[\r\n((4\\bigoplus 1)\\bigoplus 2)\\bigoplus 3）=10\\times 2\\times 3+10\\times\r\n3\\times 5+10\\times 5\\times 10=710\r\n\\]</span></p>\r\n<h4 id=\"输入格式-6\">输入格式</h4>\r\n<p>输入第一行是一个正整数 <span class=\"math inline\">\\(N(4\\le N\\le\r\n100)\\)</span>，表示项链上珠子的个数。第二行是 <span\r\nclass=\"math inline\">\\(N\\)</span> 个用空格隔开的正整数，所有的数均不超过\r\n<span class=\"math inline\">\\(1000\\)</span>。第 <span\r\nclass=\"math inline\">\\(i\\)</span> 个数为第 <span\r\nclass=\"math inline\">\\(i\\)</span> 颗珠子的头标记<span\r\nclass=\"math inline\">\\((1\\le i\\le N)\\)</span>，当 <span\r\nclass=\"math inline\">\\(i&lt;N\\)</span> 时，第 <span\r\nclass=\"math inline\">\\(i\\)</span> 颗珠子的尾标记应该等于第 <span\r\nclass=\"math inline\">\\(i+1\\)</span> 颗珠子的头标记。第 <span\r\nclass=\"math inline\">\\(N\\)</span> 颗珠子的尾标记应该等于第 <span\r\nclass=\"math inline\">\\(1\\)</span> 颗珠子的头标记。</p>\r\n<p>至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。</p>\r\n<h4 id=\"输出格式-6\">输出格式</h4>\r\n<p>输出只有一行，是一个正整数 <span class=\"math inline\">\\(E(E≤2.1\\times\r\n10^9)\\)</span>，为一个最优聚合顺序所释放的总能量。</p>\r\n<h4 id=\"解法分析-6\">解法分析</h4>\r\n<p>这题仍然是一道<a href=\"#huanxindp\">环形DP问题</a>，就不详细讲了。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">209</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n, f[N][N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">&#125; a[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;a[i].x);</span><br><span class=\"line\">        a[i+n].x = a[i].x, a[i<span class=\"number\">-1</span>].y = a[i+n<span class=\"number\">-1</span>].y = a[i].x;</span><br><span class=\"line\">    &#125; a[<span class=\"number\">2</span>*n].y = a[<span class=\"number\">1</span>].x; <span class=\"comment\">// 初始化数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> len = <span class=\"number\">1</span>; len &lt;= n; len++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i+len &lt; <span class=\"number\">2</span>*n; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> t = i + len;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = i; k &lt; t; k++)</span><br><span class=\"line\">                f[i][t] = std::<span class=\"built_in\">max</span>(f[i][t], f[i][k] + f[k+<span class=\"number\">1</span>][t] + a[i].x * a[k].y * a[t].y);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        ans = std::<span class=\"built_in\">max</span>(ans, f[i][i+n<span class=\"number\">-1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, ans);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"传纸条message\">8. 传纸条(message)</h3>\r\n<h4 id=\"题目描述-7\">题目描述</h4>\r\n<p>小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个\r\n<span class=\"math inline\">\\(m\\)</span> 行 <span\r\nclass=\"math inline\">\\(n\\)</span>\r\n列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标\r\n<span class=\"math inline\">\\((1,1)\\)</span>，小轩坐在矩阵的右下角，坐标\r\n<span class=\"math inline\">\\((m,n)\\)</span>。</p>\r\n<p>从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。</p>\r\n<p>在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。</p>\r\n<p>还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用\r\n<span class=\"math inline\">\\(0\\)</span> 表示），可以用一个 <span\r\nclass=\"math inline\">\\(0\\sim 100\\)</span>\r\n的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的两条路径。</p>\r\n<h4 id=\"输入格式-7\">输入格式</h4>\r\n<p>输入的第一行有 <span class=\"math inline\">\\(2\\)</span>\r\n个用空格隔开的整数 <span class=\"math inline\">\\(m\\)</span> 和 <span\r\nclass=\"math inline\">\\(n\\)</span>，表示班里有 <span\r\nclass=\"math inline\">\\(m\\)</span> 行 <span\r\nclass=\"math inline\">\\(n\\)</span> 列 <span class=\"math inline\">\\((1\\le\r\nm,n\\le 50)\\)</span>。</p>\r\n<p>接下来的 <span class=\"math inline\">\\(m\\)</span> 行是一个 <span\r\nclass=\"math inline\">\\(m\\times n\\)</span> 的矩阵，矩阵中第 <span\r\nclass=\"math inline\">\\(i\\)</span> 行 <span\r\nclass=\"math inline\">\\(j\\)</span> 列的整数表示坐在第 <span\r\nclass=\"math inline\">\\(i\\)</span> 行 <span\r\nclass=\"math inline\">\\(j\\)</span> 列的学生的好心程度。每行的 <span\r\nclass=\"math inline\">\\(n\\)</span> 个整数之间用空格隔开。</p>\r\n<h4 id=\"输出格式-7\">输出格式</h4>\r\n<p>输出共一行，包含一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。</p>\r\n<h4 id=\"解法分析-7\">解法分析</h4>\r\n<p>这道题难度较大，先定下状态：<code>f[i][j][p][q]</code> 表示\r\n<strong>从小渊传到小轩的纸条到达 <span\r\nclass=\"math inline\">\\((i,j)\\)</span>，从小轩传给小渊的纸条到达 <span\r\nclass=\"math inline\">\\((p,q)\\)</span>\r\n的路径上取得的最大的好心程度和</strong> （这是坐标类DP的常见状态）</p>\r\n<p>换句话说，即求<strong>第一张纸条到达 <span\r\nclass=\"math inline\">\\((i,j)\\)</span>，第二纸条到达 <span\r\nclass=\"math inline\">\\((p,q)\\)</span>\r\n的路径上取得的最大的好心程度和，且两条路径严格不相交</strong></p>\r\n<p>所以，为了保证两条路径不重复，必须限制 <span\r\nclass=\"math inline\">\\(q&gt;j\\)</span>。如果不理解为什么这么限制，那么也可以让\r\n<span class=\"math inline\">\\(q\\)</span> 从 <span\r\nclass=\"math inline\">\\(1\\)</span> 开始枚举，但是需要判断 <span\r\nclass=\"math inline\">\\((i,j)\\)</span> 与 <span class=\"math inline\">\\((p,\r\nq)\\)</span> 是否重合，若重合就把 <span class=\"math inline\">\\(f\\)</span>\r\n数组转移后减掉 <code>a[i][j]</code> 或 <code>a[p][q]</code>。</p>\r\n<p>时间复杂度 <span class=\"math inline\">\\(O(n^2\\times\r\nm^2)\\)</span>，即最多 <span class=\"math inline\">\\(6250000\\)</span>\r\n次计算，可以\r\n<font color=\"green\" size=\"5px\"><strong>AC</strong></font></p>\r\n<p>当然，可以优化这种算法。我们发现，<span\r\nclass=\"math inline\">\\(i+j=p+q=step\\)</span> ，所以可以用 <span\r\nclass=\"math inline\">\\(step\\)</span>\r\n来表示其他两维，这样就实现了四维到三维的降维。这样，时间复杂度降低到\r\n<span class=\"math inline\">\\(O(n^2\\times (n+m))\\)</span>，即最多 <span\r\nclass=\"math inline\">\\(250000\\)</span> 次计算，比上一种算法快 <span\r\nclass=\"math inline\">\\(20\\)</span>\r\n多倍。由于这种算法原理与第一种一样，就不给出代码<del>（懒）</del>，供读者思考。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> std::max;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">55</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> m, n, a[N][N], f[N][N][N][N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">max_of_four_ele</span><span class=\"params\">(<span class=\"type\">int</span> liu, <span class=\"type\">int</span> rong, <span class=\"type\">int</span> sha, <span class=\"type\">int</span> bi)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(liu, <span class=\"built_in\">max</span>(rong, <span class=\"built_in\">max</span>(sha, bi)));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> p = <span class=\"number\">1</span>; p &lt;= m; p++)</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> q = j+<span class=\"number\">1</span>; q &lt;= n; q++)</span><br><span class=\"line\">                    f[i][j][p][q] = <span class=\"built_in\">max_of_four_ele</span>(f[i<span class=\"number\">-1</span>][j][p<span class=\"number\">-1</span>][q], f[i][j<span class=\"number\">-1</span>][p<span class=\"number\">-1</span>][q], f[i<span class=\"number\">-1</span>][j][p][q<span class=\"number\">-1</span>], f[i][j<span class=\"number\">-1</span>][p][q<span class=\"number\">-1</span>]) + a[i][j] + a[p][q];</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, f[m][n<span class=\"number\">-1</span>][m<span class=\"number\">-1</span>][n]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"筷子chop\">9. 筷子(chop)</h3>\r\n<h4 id=\"题目描述-8\">题目描述</h4>\r\n<p>A\r\n先生有很多双筷子。确切的说应该是很多根，因为筷子的长度不一，很难判断出哪两根是一双的。这天，A\r\n先生家里来了 <span class=\"math inline\">\\(K\\)</span> 个客人，A\r\n先生留下他们吃晚饭。加上 A 先生，A 夫人和他们的孩子小 A，共 <span\r\nclass=\"math inline\">\\(K+3\\)</span> 个人。每人需要用一双筷子。A\r\n先生只好清理了一下筷子，共 <span class=\"math inline\">\\(N\\)</span>\r\n根，长度为 <span\r\nclass=\"math inline\">\\(T_1,T_2,T_3,\\dots,T_N\\)</span>。</p>\r\n<p>现在他想用这些筷子组合成 <span class=\"math inline\">\\(K+3\\)</span>\r\n双，使每双的筷子长度差的平方和最小。(怎么不是和最小？？这要去问 A\r\n先生了，呵呵)</p>\r\n<h4 id=\"输入格式-8\">输入格式</h4>\r\n<p>输入共有两行，第一行为两个用空格隔开的整数，表示 <span\r\nclass=\"math inline\">\\(N,K(1≤N≤100, 0&lt;K&lt;50)\\)</span>，第二行共有\r\nN<em>N</em> 个用空格隔开的整数，为 <span\r\nclass=\"math inline\">\\(T_i\\)</span>。每个整数为 <span\r\nclass=\"math inline\">\\(1\\sim 50\\)</span> 之间的数。</p>\r\n<h4 id=\"输出格式-8\">输出格式</h4>\r\n<p>输出仅一行。如果凑不齐 <span class=\"math inline\">\\(K+3\\)</span>\r\n双，输出 <span\r\nclass=\"math inline\">\\(-1\\)</span>，否则输出长度差平方和的最小值。</p>\r\n<h4 id=\"解法分析-8\">解法分析</h4>\r\n<p>背包问题变形。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">107</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n, k, a[N], f[N][N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;k); k += <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, a + i);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k+k &gt; n) &#123; <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;-1&quot;</span>); <span class=\"keyword\">return</span> <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">    std::<span class=\"built_in\">sort</span>(a + <span class=\"number\">1</span>, a + n + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(f, <span class=\"number\">0x3F</span>, <span class=\"keyword\">sizeof</span> f);</span><br><span class=\"line\">    f[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= k; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i+i; j &lt;= n; j++)</span><br><span class=\"line\">            f[i][j] = std::<span class=\"built_in\">min</span>(f[i][j<span class=\"number\">-1</span>], f[i<span class=\"number\">-1</span>][j<span class=\"number\">-2</span>] + (a[j]-a[j<span class=\"number\">-1</span>])*(a[j]-a[j<span class=\"number\">-1</span>]));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, f[k][n]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"合并石子merge\">10. 合并石子(merge)</h3>\r\n<h4 id=\"题目描述-9\">题目描述</h4>\r\n<p>在一个操场上一排地摆放着 <span class=\"math inline\">\\(N\\)</span>\r\n堆石子。现要将石子有次序地合并成一堆。规定每次只能选相邻的 <span\r\nclass=\"math inline\">\\(2\\)</span>\r\n堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的得分。</p>\r\n<p>试设计一个程序，计算出将 <span class=\"math inline\">\\(N\\)</span>\r\n堆石子合并成一堆的最小得分。</p>\r\n<h4 id=\"输入格式-9\">输入格式</h4>\r\n<p>第一行为一个正整数 <span class=\"math inline\">\\(N\\ (2\\le N\\le\r\n100)\\)</span>；</p>\r\n<p>以下 <span class=\"math inline\">\\(N\\)</span> 行,每行一个正整数，小于\r\n<span class=\"math inline\">\\(10000\\)</span>，分别表示第 <span\r\nclass=\"math inline\">\\(i\\)</span> 堆石子的个数。</p>\r\n<h4 id=\"输出格式-9\">输出格式</h4>\r\n<p>为一个正整数，即最小得分。</p>\r\n<h4 id=\"解法分析-9\"><a id=\"hebingshizi\">解法分析</a></h4>\r\n<p>这是一道最经典的区间DP了，<del>真不知道为什么我要把这题拿到最后才讲</del>。区间DP的解法在之前已经讲过了，这里不再赘述。<a href=\"#qujiandp\">点我跳转</a></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">109</span>, INF = <span class=\"number\">0x3F3F3F3F</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n, s[N], f[N][N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(f, INF, <span class=\"keyword\">sizeof</span> f);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        f[i][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, s + i), s[i] += s[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n<span class=\"number\">-1</span>; i &gt;= <span class=\"number\">1</span>; i--)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i+<span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> t = s[j] - s[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = i; k &lt; j; k++)</span><br><span class=\"line\">                f[i][j] = std::<span class=\"built_in\">min</span>(f[i][j], f[i][k] + f[k+<span class=\"number\">1</span>][j] + t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, f[<span class=\"number\">1</span>][n]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","categories":["专题"],"tags":["C++","动态规划"]},{"title":"【专题】背包问题","url":"/2022/06/14/topic-dp_knapsack/","content":"<h3 id=\"导读\">导读</h3>\r\n<p>背包问题是动态规划中非常经典的一类问题，需要仔细地思考背包问题的每一个状态转移方程。</p>\r\n<p>背包问题大致有以下几大类：</p>\r\n<ul>\r\n<li>01背包问题</li>\r\n<li>完全背包问题</li>\r\n<li>多重背包问题</li>\r\n<li>混合背包问题</li>\r\n<li>二位费用的背包问题</li>\r\n<li>分组背包问题</li>\r\n<li>背包问题求方案数</li>\r\n<li>求背包问题的方案</li>\r\n<li>有依赖的背包问题</li>\r\n</ul>\r\n<p>下面开始讨论背包问题的这些子问题：</p>\r\n<p>*本文不会讨论后面三种子问题！</p>\r\n<h3 id=\"背包问题\">01背包问题</h3>\r\n<h4 id=\"模板\">模板</h4>\r\n<p>有 <span class=\"math inline\">\\(N\\)</span> 件物品和一个容量是 <span\r\nclass=\"math inline\">\\(V\\)</span> 的背包。每件物品只能使用一次。第 <span\r\nclass=\"math inline\">\\(i\\)</span> 件物品的体积是 <span\r\nclass=\"math inline\">\\(v[i]\\)</span>，价值是 <span\r\nclass=\"math inline\">\\(w[i]\\)</span>。</p>\r\n<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p>\r\n<h4 id=\"解法分析\">解法分析</h4>\r\n<p>这是背包问题中最简单的一种子问题。其特点是:\r\n<strong>每种物品仅有一件，可以选择放或不放</strong>。</p>\r\n<p>我们首先确定状态：<span class=\"math inline\">\\(f[i][j]\\)</span> 表示前\r\n<span class=\"math inline\">\\(i\\)</span> 个物品在背包容量 <span\r\nclass=\"math inline\">\\(j\\)</span>\r\n的情况下能获得的最大价值。则其状态转移方程便是：<span\r\nclass=\"math inline\">\\(f[i][j]=std::max(f[i-1][j],\r\nf[i-1][j-v[i]]+w[i])\\)</span></p>\r\n<p>这个方程非常重要，几乎所有的跟背包问题相关的问题的方程都是由它衍生出来的。希望读者能够<strong>完全</strong>理解它。</p>\r\n<p>这里由于篇幅有限<del>（其实就是懒）</del>，给读者提供一个视频链接。这个老师讲的非常清楚。<a\r\nhref=\"https://www.bilibili.com/video/BV1K4411X766\">bilibili@codereasy\r\n背包问题</a></p>\r\n<p>本文将在上面的视频的基础上优化空间复杂度。</p>\r\n<p>以上算法的时间复杂度为<span\r\nclass=\"math inline\">\\(O(N*V)\\)</span>，空间复杂度也是<span\r\nclass=\"math inline\">\\(O(N*V)\\)</span>。其中，时间复杂度已经基本不能再优化了，但是空间复杂度可以继续优化到<span\r\nclass=\"math inline\">\\(O(V)\\)</span>。</p>\r\n<p>在每一次第二维的循环中，<span class=\"math inline\">\\(f[i][j]\\)</span>\r\n是均由 <span class=\"math inline\">\\(i-1\\)</span> 的状态得来的。<span\r\nclass=\"math inline\">\\(f[i][j]\\)</span> 与 <span\r\nclass=\"math inline\">\\(f[i-1][j]\\)</span>\r\n是相互独立的。因此，我们可以考虑将 <span\r\nclass=\"math inline\">\\(i\\)</span>\r\n这一维舍去。需要注意的是，舍弃掉第一维后，我们必须采用<strong>倒序循环</strong>的方式。如果仍然使用正序循环，那么就是从\r\n<span class=\"math inline\">\\(f[较小体积]\\)</span> 更新到 <span\r\nclass=\"math inline\">\\(f[较大体积]\\)</span>。当循环到较大体积时，可能用的是第\r\n<span class=\"math inline\">\\(i\\)</span> 轮的状态而不是第 <span\r\nclass=\"math inline\">\\(i-1\\)</span> 轮的状态。</p>\r\n<p>举个例子：当我们对一个体积为 <span class=\"math inline\">\\(8\\)</span>\r\n的物体进行决策时，<span class=\"math inline\">\\(f[19]\\)</span> 应该由\r\n<span class=\"math inline\">\\(f[11]\\)</span> 更新得到。但此时的 <span\r\nclass=\"math inline\">\\(f[11]\\)</span> 却不是第 <span\r\nclass=\"math inline\">\\(i-1\\)</span> 轮的 <span\r\nclass=\"math inline\">\\(f[11]\\)</span> ，而是这一轮刚刚更新过的 <span\r\nclass=\"math inline\">\\(f[11]\\)</span> 。说的通俗一点，即 <span\r\nclass=\"math inline\">\\(f[11]\\)</span>\r\n已经被污染了。而如果使用逆序循环，则不会有这样的问题。</p>\r\n<p>最后，我们的状态转移方程就顺水推舟地写出来了：<span\r\nclass=\"math inline\">\\(f[j]=f[j-v[i]]+w[i]\\)</span></p>\r\n<p>代码：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">39</span>, M = <span class=\"number\">209</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> m, n;</span><br><span class=\"line\"><span class=\"type\">int</span> w[N], c[N], f[M];</span><br><span class=\"line\"><span class=\"comment\">// f[j] 表示 N 件物品，背包容量 j 下的最优解</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, w + i, c + i);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = m; j &gt;= w[i]; j--)</span><br><span class=\"line\">            f[j] = std::<span class=\"built_in\">max</span>(f[j], f[j-w[i]] + c[i]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, f[m]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>例题：<a href=\"https://www.luogu.com.cn/problem/P1048\">[NOIP2005\r\n普及组] 采药</a></p>\r\n<h3 id=\"完全背包问题\">完全背包问题</h3>\r\n<h4 id=\"模板-1\">模板</h4>\r\n<p>有 <span class=\"math inline\">\\(N\\)</span> 种物品和一个容量是 <span\r\nclass=\"math inline\">\\(V\\)</span> 的背包，每种物品都有无限件可用。第\r\n<span class=\"math inline\">\\(i\\)</span> 种物品的体积是 <span\r\nclass=\"math inline\">\\(v[i]\\)</span>，价值是 <span\r\nclass=\"math inline\">\\(w[i]\\)</span>。</p>\r\n<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p>\r\n<h4 id=\"解法分析-1\">解法分析</h4>\r\n<p>完全背包的状态转移方程可以由01背包的状态转移方程演变而来，即<span\r\nclass=\"math inline\">\\(f[i,j]=max\\{f[i-1,j],f[i-1,j-v]+w,f[i-1,j-2*v]+2*w,f[i-1,j-3*v]+3*w,...\\}\\)</span>\r\n其中，<span class=\"math inline\">\\(j&gt;=k*v\\)</span></p>\r\n<p>代码：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1010</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n, m, f[N][N], v[N], w[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, v + i, w + i);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt;= m; j++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k*v[i] &lt;= j; k++)</span><br><span class=\"line\">                f[i][j] = std::<span class=\"built_in\">max</span>(f[i][j], f[i<span class=\"number\">-1</span>][j-k*v[i]] + k*w[i]);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, f[n][m]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这样的代码可能会 TLE, 所以我们得想办法优化。</p>\r\n<p>我们将两个方程放在一起看：</p>\r\n<p><span\r\nclass=\"math inline\">\\(f[i,j]=max\\{f[i-1,j],f[i-1,j-v]+w,f[i-1,j-2*v]+2*w,f[i-1,j-3*v]+3*w,...\\}\\)</span></p>\r\n<p><span class=\"math inline\">\\(f[i , j-v]= max\\{\\qquad \\ \\ f[i-1,j-v] ,\r\nf[i-1,j-2*v] + w , f[i-1,j-3*v]+2*w, ...\\}\\)</span></p>\r\n<p>将两方程整理后得到：$f[i][j]=max(f[i,j-v]+w,f[i-1][j]) $</p>\r\n<p>那么，代码就可以优化成这样：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1010</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n, m, f[N][N], v[N], w[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, v + i, w + i);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt;= m; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            f[i][j] = f[i<span class=\"number\">-1</span>][j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j - v[i] &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                f[i][j]=<span class=\"built_in\">max</span>(f[i][j], f[i][j-v[i]]+w[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, f[n][m]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>与01背包一样，我们可以将空间复杂度优化成 <span\r\nclass=\"math inline\">\\(O(V)\\)</span></p>\r\n<p>最终代码：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">209</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> m, n, f[N], w[N], c[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, w + i, c + i);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = w[i]; j &lt;= m; j++)</span><br><span class=\"line\">            f[j] = std::<span class=\"built_in\">max</span>(f[j], f[j-w[i]] + c[i]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, f[m]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>例题：<a\r\nhref=\"https://www.luogu.com.cn/problem/P2563\">[AHOI2001]质数和分解</a></p>\r\n<h3 id=\"多重背包\">多重背包</h3>\r\n<h4 id=\"模板-2\">模板</h4>\r\n<p>有 <span class=\"math inline\">\\(N\\)</span> 种物品和一个容量是 <span\r\nclass=\"math inline\">\\(V\\)</span> 的背包。第 <span\r\nclass=\"math inline\">\\(i\\)</span> 种物品最多有 <span\r\nclass=\"math inline\">\\(s[i]\\)</span> 件，每件体积是 <span\r\nclass=\"math inline\">\\(v[i]\\)</span>，价值是 <span\r\nclass=\"math inline\">\\(w[i]\\)</span>。</p>\r\n<p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。</p>\r\n<h4 id=\"解法分析-2\">解法分析</h4>\r\n<p>第一种：朴素解法</p>\r\n<p>代码好理解，就不做解释了。只要掌握了01背包的状态转移方程，这个代码问题不大。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">509</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n, m, f[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> s, v, w;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;s, &amp;v, &amp;w);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = m; j &gt;= v; j--)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k&lt;=s <span class=\"keyword\">and</span> j&gt;=k*v; k++)</span><br><span class=\"line\">                f[j] = std::<span class=\"built_in\">max</span>(f[j], f[j-k*v] + k*w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, f[m]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>注：这个代码是后来写的，将 s, v, w 数组改成了变量，应该能够看懂。</p>\r\n<p>这个代码时间复杂度较高（<span class=\"math inline\">\\(O(V\\times\r\n\\Sigma^N_{i=1}C_i)\\)</span>），当数据较小时，该代码可以通过。但是，当数据很大时，这个代码就一定会\r\nTLE。</p>\r\n<p>所以，我们考虑改善时间复杂度。应当使用<strong>二进制拆分法</strong>来将多重背包转换成01背包，再求解，速度将大幅提高。</p>\r\n<p>二进制拆分法的原理：从 <span\r\nclass=\"math inline\">\\(2^0,2^1,2^2,...,2^{k-1}\\)</span> 这 <span\r\nclass=\"math inline\">\\(k\\)</span> 个 <span\r\nclass=\"math inline\">\\(2\\)</span> 的整数次幂中选出若干个相加，可以表示出\r\n<span class=\"math inline\">\\(0\\sim 2^k-1\\)</span> 之间任何一个整数。</p>\r\n<p>例如：<span class=\"math inline\">\\(1，2，4\\)</span>可以表示 <span\r\nclass=\"math inline\">\\(1\\)</span> 至 <span\r\nclass=\"math inline\">\\(7\\)</span> 内所有的正整数。即 <span\r\nclass=\"math display\">\\[\r\n1=1\\\\\r\n2=2\\\\\r\n3=1+2\\\\\r\n4=4\\\\\r\n5=1+4\\\\\r\n6=2+4\\\\\r\n7=1+2+4\r\n\\]</span> 按照这个思路，我们可以把数量为 <span\r\nclass=\"math inline\">\\(c[i]\\)</span> 的第 <span\r\nclass=\"math inline\">\\(i\\)</span>\r\n种物品拆成若干个由二进制数组成的物品数量。例如，有一种物品有 <span\r\nclass=\"math inline\">\\(10\\)</span> 个，每个物品的价值为 <span\r\nclass=\"math inline\">\\(100\\)</span>，体积为 <span\r\nclass=\"math inline\">\\(20\\)</span>。那么，我们就要存：</p>\r\n<p>第一轮：<span class=\"math inline\">\\(w[++counter]=1*100,\\\r\nv[counter]=1*20\\)</span></p>\r\n<p>第二轮：<span class=\"math inline\">\\(w[++counter]=2*100,\\\r\nv[counter]=2*20\\)</span></p>\r\n<p>第三轮：<span class=\"math inline\">\\(w[++counter]=4*100,\\\r\nv[counter]=4*20\\)</span></p>\r\n<p>第四轮：<span class=\"math inline\">\\(w[++counter]=3*100,\\\r\nv[counter]=3*20\\)</span></p>\r\n<p>这样，我们就把多重背包问题转化成了01背包问题，时间复杂度 <span\r\nclass=\"math inline\">\\(O(log\\ C_i)\\)</span>。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">509</span>, M = <span class=\"number\">26009</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n, nn, m, f[N], v[M], w[M];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>, s, x, y; i &lt;= n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> t = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;s, &amp;x, &amp;y);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s &gt;= t)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            v[++nn] = t * x, w[nn] = t * y;</span><br><span class=\"line\">            s -= t, t &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s) &#123; v[++nn] = s * x, w[nn] = s * y; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= nn; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = m; j &gt;= v[i]; j--)</span><br><span class=\"line\">            f[j] = std::<span class=\"built_in\">max</span>(f[j], f[j-v[i]] + w[i]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, f[m]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"混合背包\">混合背包</h3>\r\n<p>混合背包即将上述的三种最基础的背包问题体型放在一种问题里。先来看模板题。</p>\r\n<h4 id=\"模板-3\">模板</h4>\r\n<p>有 <span class=\"math inline\">\\(N\\)</span> 种物品和一个容量是 <span\r\nclass=\"math inline\">\\(V\\)</span> 的背包。</p>\r\n<p>物品一共有三类：</p>\r\n<ul>\r\n<li>第一类物品只能用1次（01背包）；</li>\r\n<li>第二类物品可以用无限次（完全背包）；</li>\r\n<li>第三类物品最多只能用 <span class=\"math inline\">\\(s[i]\\)</span>\r\n次（多重背包）；</li>\r\n</ul>\r\n<p>每种体积是 <span class=\"math inline\">\\(v[i]\\)</span>，价值是 <span\r\nclass=\"math inline\">\\(w[i]\\)</span>。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。</p>\r\n<h4 id=\"解法分析-3\">解法分析</h4>\r\n<p>当该物品有无限个时，则按照完全背包的解法来处理；</p>\r\n<p>当该物品有有限个时，则按照多重背包或者01背包的解法来处理。</p>\r\n<p>代码：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">209</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> v, n, f[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;v, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>, w, c, p; i &lt;= n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;w, &amp;c, &amp;p);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = w; j &lt;= v; j++)</span><br><span class=\"line\">                f[j] = std::<span class=\"built_in\">max</span>(f[j], f[j-w] + c);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">1</span>; k &lt;= p; k++)</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = v; j &gt;= w; j--)</span><br><span class=\"line\">                    f[j] = std::<span class=\"built_in\">max</span>(f[j], f[j-w] + c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, f[v]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"二维费用的背包问题\">二维费用的背包问题</h3>\r\n<h4 id=\"模板-4\">模板</h4>\r\n<p>有 <span class=\"math inline\">\\(N\\)</span> 件物品和一个容量是 <span\r\nclass=\"math inline\">\\(V\\)</span> 的背包，背包能承受的最大重量是 <span\r\nclass=\"math inline\">\\(M\\)</span>。</p>\r\n<p>每件物品只能用一次。体积是 <span\r\nclass=\"math inline\">\\(v_i\\)</span>，重量是 <span\r\nclass=\"math inline\">\\(m_i\\)</span>，价值是 <span\r\nclass=\"math inline\">\\(w_i\\)</span>。</p>\r\n<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。</p>\r\n<h4 id=\"解法分析-4\">解法分析</h4>\r\n<p>这种题与前三种常规背包问题几乎相同，只是多了一个限定条件而已。</p>\r\n<p>回顾一维费用的背包问题，状态准是：<span\r\nclass=\"math inline\">\\(f[j]\\)</span> 表示在背包容量为 <span\r\nclass=\"math inline\">\\(j\\)</span> 的情况下能获得的最大价值</p>\r\n<p>此时，多了一个限定条件，那么我们就自然想到多增一维，即：<span\r\nclass=\"math inline\">\\(f[j][k]\\)</span> 表示在第一个限制条件为 <span\r\nclass=\"math inline\">\\(j\\)</span> ，第二个限制条件为 <span\r\nclass=\"math inline\">\\(k\\)</span> 的情况下能获得的最大价值</p>\r\n<p>同样类比一维费用的背包问题的状态转移方程，二维的状态转移方程应该这么写：\r\n<span class=\"math display\">\\[\r\nf_{j, k} = max(f_{j − v_i,\\ k − m_i},\\ f_{j,\\ k})\r\n\\]</span> 状态转移方程出来了，那么写代码也就轻松了。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">400</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> g, v, n, f[N][N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;g, &amp;v, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>, value, w1, w2; i &lt;= n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;value, &amp;w1, &amp;w2);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = g; j &gt;= w1; j--)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> l = v; l &gt;= w2; l--)</span><br><span class=\"line\">                f[j][l] = std::<span class=\"built_in\">max</span>(f[j][l], f[j - w1][l - w2] + value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, f[g][v]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"分组背包\">分组背包</h3>\r\n<h4 id=\"模板-5\">模板</h4>\r\n<p>有 <span class=\"math inline\">\\(N\\)</span> 组物品和一个容量是 <span\r\nclass=\"math inline\">\\(V\\)</span> 的背包。</p>\r\n<p>每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是\r\n<span class=\"math inline\">\\(v_{i,j}\\)</span>，价值是 <span\r\nclass=\"math inline\">\\(w_{i,j}\\)</span>，其中 <span\r\nclass=\"math inline\">\\(i\\)</span> 是组号，<span\r\nclass=\"math inline\">\\(j\\)</span>\r\n是组内编号。求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p>\r\n<h4 id=\"解法分析-5\">解法分析</h4>\r\n<p>这个问题变成了每组物品有若干个策略：是选择本组的某一件，还是不选。</p>\r\n<p>状态转移方程：<span class=\"math inline\">\\(f[k][v]=max\\{f[k-1][v],\\\r\nf[k-1][v-w[i]]+c[i]\\bigg| 物品i\\in 第k组 \\}\\)</span></p>\r\n<p>代码：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">39</span>, M = <span class=\"number\">209</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> v, n, t;</span><br><span class=\"line\"><span class=\"type\">int</span> w[N], c[N], a[<span class=\"number\">11</span>][N], f[M];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;v, &amp;n, &amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>, p; i &lt;= n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, w + i, c + i, &amp;p);</span><br><span class=\"line\">        a[p][++a[p][<span class=\"number\">0</span>]] = i; <span class=\"comment\">// a[p][0] is the number of items in group p</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">1</span>; k &lt;= t; k++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = v; j &gt;= <span class=\"number\">0</span>; j--)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= a[k][<span class=\"number\">0</span>]; i++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j&gt;=w[a[k][i]] <span class=\"keyword\">and</span> f[j]&lt;f[j-w[a[k][i]]]+c[a[k][i]])</span><br><span class=\"line\">                    f[j] = f[j-w[a[k][i]]] + c[a[k][i]];</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, f[v]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"秘笈\">秘笈</h3>\r\n<ul>\r\n<li><span class=\"math inline\">\\(f\\)</span>\r\n数组的大小一定由<strong>限制条件</strong>的大小决定</li>\r\n<li>循环处理背包问题时，第一层循环永远一一是<strong>枚举物品个数或组别</strong>（重要）</li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> f[N]; <span class=\"comment\">// N 为价值或重量(即限定条件)的最大值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= %物品个数或组数%; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = %背包容量或价值最大值%; j &gt;= %第i件物品的价值或体积%; j--) <span class=\"comment\">// 这一行不绝对，可能会正序循环或者其他。</span></span><br><span class=\"line\">            f[j] = std::<span class=\"built_in\">max</span>(f[j], f[j-w[i]] + c[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","categories":["专题"],"tags":["C++","动态规划","背包DP"]},{"title":"【专题】最长不下降子序列","url":"/2022/06/14/topic-dp_lis/","content":"<p>题目描述就不写了，这题实在太经典了。</p>\r\n<p>下面重点分析算法：</p>\r\n<p>大家都知道，这题是一道<strong>动态规划</strong>的入门题。众所周知，动态规划的题都可以通过<strong>搜索</strong>来<del>骗分</del>获得一定的分数。所以，对于这道题，我们仍然可以先用<span\r\nclass=\"math inline\">\\(dfs\\)</span>写出来。代码较为暴力好懂，就不做解释。这个代码可以获得40-60分(视不同的OJ而定)</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">109</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n = <span class=\"number\">1</span>, mx = <span class=\"number\">-1</span>, a[N], ans[N], anss[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> cnt)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &gt; n)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cnt &gt; mx)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        mx = cnt;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(anss, ans, N);</span><br><span class=\"line\">        <span class=\"comment\">// printf(&quot;mx=%d\\n&quot;, mx);</span></span><br><span class=\"line\">        <span class=\"comment\">// for (int i = 1; i &lt;= mx; i++)</span></span><br><span class=\"line\">        <span class=\"comment\">//     printf(&quot;%d &quot;, ans[i]);</span></span><br><span class=\"line\">        <span class=\"comment\">// puts(&quot;&quot;);</span></span><br><span class=\"line\">        <span class=\"comment\">// puts(&quot;----------&quot;);</span></span><br><span class=\"line\">        <span class=\"comment\">// 这个注释可供大家看看这个程序的处理过程，以便小白更好的理解这段代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = x; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[i] &gt; ans[cnt])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ans[++cnt] = a[i];</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(i+<span class=\"number\">1</span>, cnt);</span><br><span class=\"line\">            ans[cnt--] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, a + n)) n++; n--;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, mx);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= mx; i++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, anss[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>测试样例：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://img-blog.csdnimg.cn/548e2a7a05c94f5db1bc84a33ad124ab.png#pic_center\"\r\nalt=\"测试样例\" />\r\n<figcaption aria-hidden=\"true\">测试样例</figcaption>\r\n</figure>\r\n<p>第一步. 确定状态</p>\r\n<p>通常处理数列的题目, 我们都有现成的状态划分, 即从第一个数开始,\r\n到第<span class=\"math inline\">\\(n\\)</span>个数结束. <span\r\nclass=\"math display\">\\[\r\nf[i]代表前i个数中的最长不下降子序列的长度\r\n\\]</span> 这时候有个问题: 第<span\r\nclass=\"math inline\">\\(i\\)</span>个数我到底是取它还是舍它?\r\n如果不包含<span class=\"math inline\">\\(i\\)</span>,\r\n那就没法写出状态转移方程.</p>\r\n<p>不妨改成: <span class=\"math display\">\\[\r\nf[i]为前i个数的最长不下降序列的长度, 必须以第i个数结尾\r\n\\]</span> 第二步. 状态转移方程</p>\r\n<p>为了方便描述, 我们将输入定为为<span\r\nclass=\"math inline\">\\(a\\)</span>数组, 储存动态规划结果数组定义为<span\r\nclass=\"math inline\">\\(f\\)</span>数组</p>\r\n<p>根据状态, 我们推导出状态转移方程: <span\r\nclass=\"math inline\">\\(f[i]=max(f[j])+1\\)</span>, 其中<span\r\nclass=\"math inline\">\\(a[j]&lt;a[i]且j&lt;i\\)</span>.\r\n原因可以通过图示来说明.</p>\r\n<p><img\r\nsrc=\"https://img-blog.csdnimg.cn/b15a51a5541d4f89b5f1aba564ecaed1.png#pic_center\" /></p>\r\n<p>易得<span class=\"math inline\">\\(f[1]=1\\)</span>,\r\n因为它独立成为一个最长不下降子序列</p>\r\n<p><img\r\nsrc=\"https://img-blog.csdnimg.cn/87e2afa3c62045189a036039e958ee27.png#pic_center\" /></p>\r\n<p>因为<span class=\"math inline\">\\(7&lt;13\\)</span>, 所以不存在<span\r\nclass=\"math inline\">\\(a[j]&lt;a[i]且j&lt;i\\)</span>.</p>\r\n<p><img\r\nsrc=\"https://img-blog.csdnimg.cn/df1816e89b4b46b39038361a283143fb.png#pic_center\" /></p>\r\n<p>此时, 存在<span class=\"math inline\">\\(7&lt;9\\)</span>, 所以<span\r\nclass=\"math inline\">\\(mx=f[2]=1\\)</span>. <span\r\nclass=\"math inline\">\\(f[3]=mx+1=2\\)</span>.</p>\r\n<p><img\r\nsrc=\"https://img-blog.csdnimg.cn/2d9b110e9b5543cd887780576a9b9091.png#pic_center\" /></p>\r\n<p>此时, 存在<span class=\"math inline\">\\(7&lt;16,9&lt;16\\)</span>,\r\n所以<span class=\"math inline\">\\(mx=max(f[2],f[3])=f[3]=2\\)</span>. <span\r\nclass=\"math inline\">\\(f[4]=mx+1=3\\)</span></p>\r\n<p>以此类推... 直至算到<span class=\"math inline\">\\(f[14]\\)</span>,\r\n结束循环. 此时, <code>max&#123;f[i]&#125;</code>即为答案.</p>\r\n<p>因此, 有以下代码:</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">109</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n = <span class=\"number\">1</span>, ans, a[N], f[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, a + n)) n++; n--;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; i; j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j]&lt;a[i] <span class=\"keyword\">and</span> mx&lt;f[j])</span><br><span class=\"line\">                mx = f[j];</span><br><span class=\"line\">        f[i] = mx + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f[i] &gt; ans)</span><br><span class=\"line\">            ans = f[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, ans);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>部分OJ还要求输出最长不下降序列. 这似乎很难写,\r\n实际上我们只需要加一个数组和一个变量就可以搞定.</p>\r\n<p>为了方便描述, 我们将元素<span\r\nclass=\"math inline\">\\(i\\)</span>的前驱定为<span\r\nclass=\"math inline\">\\(pre[i]\\)</span>.</p>\r\n<p>找出所有满足<span\r\nclass=\"math inline\">\\(a[j]&lt;a[i]且j&lt;i\\)</span>的<span\r\nclass=\"math inline\">\\(j\\)</span>. 求出<code>max&#123;a[j]&#125;</code>的下标<span\r\nclass=\"math inline\">\\(id\\)</span>, 那么记录<span\r\nclass=\"math inline\">\\(pre[i]=id\\)</span>.\r\n可以通过图示来帮助更好的理解.</p>\r\n<p><img\r\nsrc=\"https://img-blog.csdnimg.cn/10b230bd230d455b9e8dac69f297465d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAV2lsbEhvdQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" /></p>\r\n<p><span class=\"math inline\">\\(pre[1]\\)</span>没有前驱, 故<span\r\nclass=\"math inline\">\\(pre[1]=0\\)</span>.</p>\r\n<p><img\r\nsrc=\"https://img-blog.csdnimg.cn/21c8e6680ced4fe7a64584a57306a7ff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAV2lsbEhvdQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" /></p>\r\n<p><span class=\"math inline\">\\(7\\)</span>之前没有比它大的, 所以<span\r\nclass=\"math inline\">\\(pre[2]=0\\)</span>.</p>\r\n<p><img\r\nsrc=\"https://img-blog.csdnimg.cn/9da692df63bb42abbce6a9501cdbeb86.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAV2lsbEhvdQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" /></p>\r\n<p><span class=\"math inline\">\\(9\\)</span>之前有<span\r\nclass=\"math inline\">\\(7&lt;9\\)</span>, 所以<span\r\nclass=\"math inline\">\\(pre[3]=max\\{a[j]\\}的下标=a[2]的下标=2\\)</span>.</p>\r\n<p><img\r\nsrc=\"https://img-blog.csdnimg.cn/1c0d3d1451ea4baf80593842d0ce4044.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAV2lsbEhvdQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" /></p>\r\n<p><span class=\"math inline\">\\(16\\)</span>之前有<span\r\nclass=\"math inline\">\\(7&lt;16,9&lt;16\\)</span>, 所以<span\r\nclass=\"math inline\">\\(pre[4]=max\\{a[j]\\}的下标=a[3]的下标=3\\)</span>.</p>\r\n<p>以此类推... 直至<span class=\"math inline\">\\(pre[14]\\)</span>,\r\n然后递归<span\r\nclass=\"math inline\">\\(print(pre[max\\{f[i]的下标\\}])\\)</span>, 直至<span\r\nclass=\"math inline\">\\(x=0\\)</span>结束输出.</p>\r\n<p>因此, 有如下代码: (代码中的<span\r\nclass=\"math inline\">\\(sid\\)</span>即上文分析中的<span\r\nclass=\"math inline\">\\(id\\)</span>)</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">109</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n = <span class=\"number\">1</span>, ans, sid, a[N], f[N], pre[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(pre[x]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, a[x]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (~<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, a + n)) n++; n--;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> mx = <span class=\"number\">0</span>, id = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; i; j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j]&lt;a[i] <span class=\"keyword\">and</span> mx&lt;f[j])</span><br><span class=\"line\">                mx = f[j], id = j;</span><br><span class=\"line\">        f[i] = mx + <span class=\"number\">1</span>, pre[i] = id;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f[i] &gt; ans)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ans = f[i];</span><br><span class=\"line\">            sid = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, ans);</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(sid);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","categories":["专题"],"tags":["C++","动态规划"]},{"title":"水圈","url":"/2022/06/14/slack_off/","content":"<p>欢迎各位同学前来水评论~</p>\r\n<p>Bilibili 测试</p>\r\n<iframe src=\"//player.bilibili.com/player.html?aid=2271112&amp;bvid=BV1es411D7sW&amp;cid=3540266&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\">\r\n</iframe>\r\n","categories":["测试"],"tags":["test"]},{"title":"【题解】异或序列","url":"/2022/06/08/solution-xor_sq/","content":"<h3 id=\"题目描述\">题目描述</h3>\r\n<p>Venn有一个数列<span\r\nclass=\"math inline\">\\(a_1,a_2,...,a_n\\)</span>.有一天，BLUESKY007拿来了一个正整数<span\r\nclass=\"math inline\">\\(X\\)</span>。Venn是一个特别喜欢异或(xor)运算的孩子，她也很喜欢BLUESKY007。于是，Venn就想知道，自己能找到多少对数(i,j)能够满足<span\r\nclass=\"math inline\">\\(a_i \\ xor \\ a_j = X\\)</span>. 两个数对<span\r\nclass=\"math inline\">\\((i_1,j_1)\\)</span>与<span\r\nclass=\"math inline\">\\((i_2,j_2)\\)</span>不同，当且仅当<span\r\nclass=\"math inline\">\\(i_1 \\neq i_2\\)</span>或者<span\r\nclass=\"math inline\">\\(j_1 \\neq j_2\\)</span>。</p>\r\n<h3 id=\"思路\">思路</h3>\r\n<p>这题暴力肯定要超时（50分）。固要用二分查找。</p>\r\n<h3 id=\"解析\">解析</h3>\r\n<p>这道题除了用上面的算法外，还有一个比较容易理解的方法，详见代码。</p>\r\n<p>这道题首先需要知道一个性质: 如果 <code>a ^ b = c</code>, 则\r\n<code>a ^ c = b</code>, <code>b ^ c = a</code>.</p>\r\n<p><strong>不知道这个性质, 这道题西奈.</strong></p>\r\n<p>当你有一个有序数组, 应该怎样快速的判断这个数组里有多少个值等于 x\r\n的数呢?</p>\r\n<p>eg. <code>a[] = &#123;1, 2, 4, 5, 5, 6, 6, 10, 23, 74&#125;;</code> 且数组长度\r\nn = 10, 你要查询这个数组里出现了多少次 x = 5.</p>\r\n<p>先求出第一个大于 x 的数的地址, 再求出第一个大于等于 x 的数的地址,\r\n两者相减就是答案. 即： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans = std::<span class=\"built_in\">upper_bound</span>(a, a+n, x) - std::<span class=\"built_in\">lower_bound</span>(a, a+n, x);</span><br></pre></td></tr></table></figure> 那么有同学要问了:\r\n<code>std::upper_bound</code> 和 <code>std::lower_bound</code>\r\n不是返回地址吗?</p>\r\n<p>Answer: <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> (std::upper_bound(a, a+n, x) - a) - (std::lower_bound(a, a+n, x) - a)</span><br><span class=\"line\">=std::upper_bound(a, a+n, x) - a - std::lower_bound(a, a+n, x) + a // 两个 a 抵消, 得</span><br><span class=\"line\">=std::upper_bound(a, a+n, x) - std::lower_bound(a, a+n, x)</span><br></pre></td></tr></table></figure></p>\r\n<p>时间复杂度为 <span class=\"math inline\">\\(O(log n) \\ll\r\nO(n)\\)</span>.</p>\r\n<p><strong>不知道这个性质, 这道题西奈.</strong></p>\r\n<p>这道题还有一个比较坑的, 就是时限太小.\r\n所以你必须手写排序或者手写二分以提高效率.</p>\r\n<p><strong>不知道这一点, 这道题西奈.</strong></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> LL;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e6</span> + <span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n, x, a[N];</span><br><span class=\"line\"><span class=\"type\">int</span> b[N], c[<span class=\"number\">260</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">rsort</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"number\">32</span>; k += <span class=\"number\">8</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(c, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> c);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) ++c[a[i]&gt;&gt;k &amp; <span class=\"number\">0xFF</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">0xFF</span>; ++i) c[i] += c[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n; i; --i) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> t = a[i]&gt;&gt;k &amp; <span class=\"number\">0xFF</span>;</span><br><span class=\"line\">            b[c[t]--] = a[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(a+<span class=\"number\">1</span>, b+<span class=\"number\">1</span>, n*<span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;x);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, a + i);</span><br><span class=\"line\">    <span class=\"built_in\">rsort</span>();</span><br><span class=\"line\">    LL ans = <span class=\"number\">0</span>, last = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[i] == a[i<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">            ans += last;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> t = a[i] ^ x;</span><br><span class=\"line\">        last = std::<span class=\"built_in\">upper_bound</span>(a+<span class=\"number\">1</span>, a+n+<span class=\"number\">1</span>, t) - std::<span class=\"built_in\">lower_bound</span>(a+<span class=\"number\">1</span>, a+n+<span class=\"number\">1</span>, t);</span><br><span class=\"line\">        ans += last;</span><br><span class=\"line\">        <span class=\"comment\">// printf(&quot;when i=%d, last=%d\\n&quot;, i, last);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>, ans);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","categories":["题解"],"tags":["C++","二分"]},{"title":"【题解】全排列问题的详解","url":"/2022/06/06/solution-permutation/","content":"<h4 id=\"原题链接\">原题链接</h4>\r\n<p><a\r\nhref=\"https://www.acwing.com/problem/content/description/96/\">点我跳转</a></p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>本题最容易想到的两种解法是 DFS 与 STL\r\n这两种解法。我对前两种解法不作解释。</p>\r\n<p>普通解法(dfs): <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> n, a[<span class=\"number\">19</span>];</span><br><span class=\"line\"><span class=\"type\">bool</span> st[<span class=\"number\">19</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k &gt; n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, a[i]);</span><br><span class=\"line\">        <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (st[i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        st[i] = <span class=\"literal\">true</span>, a[k] = i;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(k+<span class=\"number\">1</span>);</span><br><span class=\"line\">        st[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\r\n<p>STL 解法: <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> n, a[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        a[i] = i;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, a[i]);</span><br><span class=\"line\">        <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (std::<span class=\"built_in\">next_permutation</span>(a+<span class=\"number\">1</span>, a+n+<span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\r\n<p>下面介绍两种比较烧脑的方法:</p>\r\n<p>烧脑: <strong>纯</strong>位运算解法</p>\r\n<p>其实这种方法也并不是很难理解, 只是把 OIer 通常写的 <code>a[]</code>\r\n换成了 <code>(long long)a</code>, 实现了空间上的大幅优化.\r\n读者可以将这个代码与上面第一个代码比对, 以更好地理解这个代码.\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> a;</span><br><span class=\"line\"><span class=\"type\">int</span> n, st;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k &gt; n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld &quot;</span>, (a&gt;&gt;<span class=\"number\">4</span>*i) &amp; <span class=\"number\">0xF</span>);</span><br><span class=\"line\">        <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">long</span> <span class=\"type\">long</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x = <span class=\"number\">1</span> &lt;&lt; i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (st &amp; x) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        st |= x, a |= i &lt;&lt; (<span class=\"number\">4</span>*k);</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(k+<span class=\"number\">1</span>);</span><br><span class=\"line\">        st ^= x, a ^= i &lt;&lt; (<span class=\"number\">4</span>*k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\r\n<p>烧脑: <strong>for 循环</strong>解法:</p>\r\n<p>这种解法比较生僻, 值得仔细介绍. 虽然这种方法的代码量要比前三种都大,\r\n但是它有几点好处:</p>\r\n<ul>\r\n<li>优化了时间复杂度(但幅度不大)</li>\r\n<li>锻炼思维</li>\r\n<li><del>装逼</del></li>\r\n</ul>\r\n<p><img\r\nsrc=\"https://img-blog.csdnimg.cn/img_convert/81627f30c161f887ffd41f265afd49a9.png\" />\r\n上面的是 for, 下面的是 dfs</p>\r\n<p>下面正式开始分析这个算法.</p>\r\n<p>我们可以通过列表的方式找出规律. 不妨设 <code>n=6</code>,\r\n那么全排列的前 <span class=\"math inline\">\\(5\\)</span> 项就是:</p>\r\n<p><img\r\nsrc=\"https://img-blog.csdnimg.cn/img_convert/732b126abf0d03dc0ed1b6a5484c8caa.png\" /></p>\r\n<p>然后我们标出每次交换的两个数标记出来:</p>\r\n<p><img\r\nsrc=\"https://img-blog.csdnimg.cn/img_convert/0d0398348adcfc4302ac230176298062.png\" /></p>\r\n<p>观察这几对数, 可以得出这样的算法: <strong>从右往左看,\r\n找出第一个降序的较小的数字 a, 拿最右边大于 a 的数字和它交换一下,\r\n剩余的右边反转.</strong></p>\r\n<p>例如, 若要求解全排列中第六组与第七组数, 那么应该这样求:</p>\r\n<p>图例: 蓝色与绿色部分为待交换的两个数, 标为黄色的数为待反转的数.</p>\r\n<p><img\r\nsrc=\"https://img-blog.csdnimg.cn/img_convert/bb43d4e3d1cc171105115b6b941157b0.png\" />\r\n第六组变化过程</p>\r\n<p><img\r\nsrc=\"https://img-blog.csdnimg.cn/img_convert/88ce38e6bb0495f6ff74f83414321240.png\"\r\nalt=\"1654495893256.png\" /> 第七组变化过程</p>\r\n<p>至此, 算法分析完毕.</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n, cnt = <span class=\"number\">1</span>, a[N], b[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"type\">int</span> &amp;a, <span class=\"type\">int</span> &amp;b)</span> </span>&#123; a ^= b ^= a ^= b; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"type\">int</span> st, <span class=\"type\">int</span> ed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = st, j = ed; i &lt; j; i++, j--)</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(a[i], a[j]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = cnt+<span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[i] &gt; a[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        a[i] = i, <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, a[i]);</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>, x, y; i &lt;= n; i++) &#123; <span class=\"comment\">// 后 i 个</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"built_in\">check</span>()) &#123;</span><br><span class=\"line\">            <span class=\"type\">bool</span> flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = n<span class=\"number\">-1</span>; j &gt;= <span class=\"number\">1</span>; j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = n; k &gt; j; k--) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (a[k] &gt; a[j]) &#123;</span><br><span class=\"line\">                        x = j, y = k;</span><br><span class=\"line\">                        flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (flag) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125; <span class=\"comment\">// 找出第一个降序</span></span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(a[x], a[y]);</span><br><span class=\"line\">            <span class=\"built_in\">reverse</span>(x+<span class=\"number\">1</span>, n);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, a[j]);</span><br><span class=\"line\">            <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","categories":["题解"],"tags":["C++","深搜","位运算"]}]